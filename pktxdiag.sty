\NeedsTeXFormat{LaTeX2e}[1994/06/01]
\ProvidesPackage{pktxdiag}[2015/02/09 Tikz add-on for packet exchange diagrams]

\DeclareOption{debug}{\pktxd@debugtrue}
\newif\ifpktxd@debug

% use PackageWarning rather than PackageError when canceling expired
% timers.  Also 'warn only' env option.
\DeclareOption{warnonly}{\pktxd@warnonlytrue}
\newif\ifpktxd@warnonly

\ProcessOptions

\RequirePackage{xstring} % \IfBeginWith in @settrans
\RequirePackage{tikz}
\RequirePackage{pgfkeys}
\usetikzlibrary{decorations.pathmorphing} % for drawing zigzag


\pgfkeys{/pktxd/.search also={/tikz}}

\newcommand{\pktxd@error}[2]{
  \ifpktxd@warnonly\PackageWarning{pktxdiag}{#1}
  \else\PackageError{pktxdiag}{#1}{#2}
  \fi}


\newcommand{\pktxd@debug}[1]{
  \ifpktxd@debug\typeout{pktxd@debug: #1}\fi}

\ifpktxd@debug\colorlet{graphicbackground}{orange}
\else\colorlet{graphicbackground}{white}\fi

% multiple entities mode?
% false globaly, set to true in env scope by 'entities' key
\newif\ifpktxd@mmode

\newif\ifpktxd@h  % is current env horizontal?

%%%%%% option keys

% arrow cmd keys
\pgfkeys{
  /pktxd/global/.is family,
  /pktxd/trans/.belongs to family=/pktxd/global,
  /pktxd/sh/.belongs to family=/pktxd/global,
  /pktxd/prop/.belongs to family=/pktxd/global,
  /pktxd/late/.belongs to family=/pktxd/global,
  /pktxd/timed/.belongs to family=/pktxd/global,
  /pktxd/timed2/.belongs to family=/pktxd/global,
  /pktxd/delayed/.belongs to family=/pktxd/global,
  /pktxd/delayed2/.belongs to family=/pktxd/global,
  /pktxd/stop/.belongs to family=/pktxd/global,
  /pktxd/stop2/.belongs to family=/pktxd/global,
  /pktxd/cancel/.belongs to family=/pktxd/global,
  /pktxd/cancel2/.belongs to family=/pktxd/global,
  /pktxd/snote/.belongs to family=/pktxd/global,
  /pktxd/rnote/.belongs to family=/pktxd/global,
  /pktxd/snoteoffset/.belongs to family=/pktxd/global,
  /pktxd/rnoteoffset/.belongs to family=/pktxd/global,
  %
  /pktxd/name/.belongs to family=/pktxd/global,
  /pktxd/id/.belongs to family=/pktxd/global,
  /pktxd/.belongs to family=/pktxd/global,
}

%% ZZZ do we need that? yes for prop and trans...
\pgfkeys{/pgf/key filters/active families/.install key filter}

%% keys controlling frame characteristics

\pgfkeys{
  /pktxd/debug/.is if=pktxd@debug,
  /pktxd/warn only/.is if=pktxd@warnonly,
  /pktxd/prop/.default=1cm,
  /pktxd/prop/.code=\setlength{\pktxd@prop}{#1},
  % 
  /pktxd/trans/.default=10mm,
  /pktxd/trans/.code=\ifpktxd@h\setlength{\pktxd@trans}{#1}\fi,
  % 
  /pktxd/sh/.style=trans=5mm,
  % 
  /pktxd/lost/.is if=pktxd@lost,
  /pktxd/bad/.is if=pktxd@bad,
  %
  /pktxd/late/.default=4cm,
  /pktxd/late/.code=\pktxd@latetrue\setlength{\pktxd@latev}{#1},
  /pktxd/timed/.value required,
  /pktxd/timed/.code 2 args=\pktxd@addtimed{1}{#1}{#2},
  /pktxd/timed2/.value required,
  /pktxd/timed2/.code 2 args=\pktxd@addtimed{2}{#1}{#2},
  % 
  /pktxd/cancel/.code=\pktxd@addcancel{1},
  /pktxd/cancel2/.code=\pktxd@addcancel{2},
  /pktxd/delayed/.value required,
  /pktxd/delayed/.code 2 args={\pktxd@delayedtrue\edef\pktxd@delayedid{1}\edef\pktxd@delayedlen{#1}\edef\pktxd@delayedlabel{#2}},
  /pktxd/delayed2/.value required,
  /pktxd/delayed2/.code 2 args={\pktxd@delayedtrue\edef\pktxd@delayedid{2}\edef\pktxd@delayedlen{#1}\edef\pktxd@delayedlabel{#2}},
  /pktxd/stop/.value required,
  /pktxd/stop/.code n args={3}{\pktxd@stoptrue\edef\pktxd@stopid{1}
    \edef\pktxd@stoplen{#1}\edef\pktxd@stoplabel{#2}\edef\pktxd@stopdelay{#3}},
  /pktxd/stop2/.value required,
  /pktxd/stop2/.code n args={3}{\pktxd@stoptrue\edef\pktxd@stopid{2}\edef\pktxd@stoplen{#1}\edef\pktxd@stoplabel{#2}\edef\pktxd@stopdelay{#3}}}

\newif\ifpktxd@bad\pktxd@badfalse
\newif\ifpktxd@lost\pktxd@lostfalse
\newif\ifpktxd@late\pktxd@latefalse
\newif\ifpktxd@delayed\pktxd@delayedfalse
\newif\ifpktxd@stop\pktxd@stopfalse
\newif\ifpktxd@sync\pktxd@synctrue

%% the list of timers started by the current frame
%% it has a dumb last element to avoid the loop break on a final comma
%% @processtimed is called in @frame
\def\pktxd@timeds{0/0/0}
\newcommand{\pktxd@addtimed}[3]{
  \pktxd@debug{addtimed #1,#2,#3}
  \edef\pktxd@timeds{#1/#2/{#3},\pktxd@timeds}}

\def\pktxd@processtimed #1/#2/#3:#4{ % id/len/label:entity
  \if 0#1\else
  \pktxd@debug{timed: id #1 ~ len #2 ~ label #3}
  \pgfmathsetlengthmacro\temp{\Tsend+\pktxd@trans}
  \pktxd@starttimer{#4}{\align}{#1}{\temp}{#2}{#3}\fi}

%% same idea for cancelled timers
\def\pktxd@cancels{0}
\newcommand{\pktxd@addcancel}[1]{\edef\pktxd@cancels{#1,\pktxd@cancels}}

\pgfkeys{
  /pktxd/cross for lost/.is if=pktxd@crosslost,
  /pktxd/rnote/.code={\def\pktxd@rnote{#1}\pktxd@rnotetrue},
  /pktxd/snote/.code={\def\pktxd@snote{#1}\pktxd@snotetrue},
  /pktxd/snoteoffset/.code=\def\pktxd@snoteoffset{#1},
  /pktxd/snoteoffset/.default=0,
  /pktxd/rnoteoffset/.code=\def\pktxd@rnoteoffset{#1},
  /pktxd/rnoteoffset/.default=0,
  /pktxd/noteoffset/.style={snoteoffset=#1,rnoteoffset=#1}}

\newif\ifpktxd@crosslost
\newif\ifpktxd@snote
\newif\ifpktxd@rnote
\def\pktxd@snoteoffset{3mm}
\def\pktxd@rnoteoffset{3mm}


\pgfkeys{/pktxd/name/.code=\def\pktxd@latename{#1}}

\def\pktxd@latename{lateframe}

\pgfkeys{/pktxd/show label2/.is if=pktxd@showlabelii}
\pgfkeys{/pktxd/hide label/.is if=pktxd@hidelabel}
\pgfkeyssetvalue{/pktxd/fade value}{0.25}
\pgfkeys{
  /pktxd/hide/.code=\pktxd@sethides{#1},
  /pktxd/ignore/.code=\pktxd@setignore{#1},
  /pktxd/fade/.code=\pktxd@setfade{#1}}

\newif\ifpktxd@showlabelii
\newif\ifpktxd@hidelabel
\pgfkeyssetvalue{/pktxd/label2}{}

\pgfkeys{
  /pktxd/timerAoffset/.style={/pktxd/default/timers/l/1/offset=#1},
  /pktxd/timerAioffset/.style={/pktxd/default/timers/l/2/offset=#1},
  /pktxd/timerBoffset/.style={/pktxd/default/timers/r/1/offset=#1},
  /pktxd/timerBioffset/.style={/pktxd/default/timers/r/2/offset=#1},
  % 
  /pktxd/timer offset/.style={/pktxd/timerAoffset=#1,/pktxd/timerBoffset=#1},
  /pktxd/timeri offset/.style={/pktxd/timerAioffset=#1,/pktxd/timerBioffset=#1}}


% since we fail to define several keys in a \if
% used for left timers when pktxd@bottomuptrue
\pgfkeys{/pktxd/reverse/.style={/tikz/rotate=180,/tikz/above},
         /pktxd/fill/.style={fill=graphicbackground}}

%% states and actions
\pgfkeys{
  /pktxd/action time offset/.code=\setlength{\pktxd@actiontimeoffset}{#1},
  /pktxd/action offset/.code=\setlength{\pktxd@actionoffset}{#1},
  /pktxd/action length/.code=\setlength{\pktxd@actionlength}{#1},
  /pktxd/state offset/.code=\setlength{\pktxd@stateoffset}{#1}}

\newlength{\pktxd@actiontimeoffset}\setlength{\pktxd@actiontimeoffset}{1mm}
\newlength{\pktxd@actionoffset}\setlength{\pktxd@actionoffset}{1mm}
\newlength{\pktxd@actionlength}\setlength{\pktxd@actionlength}{5mm}
\newlength{\pktxd@stateoffset}\setlength{\pktxd@stateoffset}{12mm}

%% environment keys

\pgfkeys{
  /pktxd/entities/.code=\pktxd@initmentities{#1},
  /pktxd/space same/.code=\setlength{\pktxd@spacesame}{#1},
  /pktxd/space other/.code=\setlength{\pktxd@spaceother}{#1},
  /pktxd/width/.code=\def\pktxd@width{#1},
  /pktxd/reversed/.is if=pktxd@reversed}

\newlength{\pktxd@spacesame}\setlength{\pktxd@spacesame}{1cm}
\newlength{\pktxd@spaceother}\setlength{\pktxd@spaceother}{5mm}
\def\pktxd@width{2.75cm}
\newif\ifpktxd@reversed

\pgfkeys{
  % in two-entities mode, these are valid options for env
  % (we cannot create them *inside* the env...)
  /pktxd/A/.code=\pgfkeyssetvalue{/pktxd/entities/A}{#1},
  /pktxd/A/.default=A,
  /pktxd/B/.code=\pgfkeyssetvalue{/pktxd/entities/B}{#1},
  /pktxd/B/.default=B,
  %
  % TODO: merge in one key?
  /pktxd/timers/.is choice,
  /pktxd/timers/above/.code={},
  /pktxd/timers/left bottom up/.is if=pktxd@timerleftbottomup,
  /pktxd/timers/left below/.is if=pktxd@timerleftbelow,
  /pktxd/timers/on arrow/.code={\pktxd@timeronarrowtrue\def\pktxd@timerlabeladd{#1}},
  /pktxd/timers/on arrow/.default=5mm}
  
% timer label on arrow effective only if label width+this value is
% less than the timer width
\def\pktxd@timerlabeladd{}

\newif\ifpktxd@timeronarrow
\newif\ifpktxd@timerleftbottomup
\newif\ifpktxd@timerleftbelow

% by default frames whose label starts with ACK are short
% key 'no shorts' removes this rule
% key hdlc sets names for HDLC
% key shorts=list sets the names of short frames

\pgfkeys{/pktxd/hdlc/.code=\edef\pktxd@shorts{\pktxd@shortshdlc}}
\pgfkeys{/pktxd/shorts/.code=\def\pktxd@shorts{#1}}
\pgfkeys{/pktxd/no shorts/.code=\def\pktxd@shorts{}}

\def\pktxd@shorts{ACK}
\def\pktxd@shortshdlc{RR,RNR,REJ,SREJ,SABM,DISC,UA}

\pgfkeyssetvalue{/pktxd/short trans}{7mm}

% sets value of \pktxd@trans based on label #1
\newcommand{\pktxd@settrans}[1]{
  \ifpktxd@h
  \gdef\pktxd@thistrans{\pktxd@trans}
  % command from xstring package
  % only the first line of multi line labels is considered
  % (otherwise, this crashes)
  \expandarg
  \foreach \x in \pktxd@shorts {
    \IfBeginWith{#1}{\x}{\gdef\pktxd@thistrans{\pgfkeysvalueof{/pktxd/short trans}}}{}
  }
  \setlength{\pktxd@trans}{\pktxd@thistrans}
  \fi
}


%%%%%% flows

%% the 'main' flowid
\pgfkeyssetvalue{/pktxd/id}{main}
\pgfkeyssetvalue{/pktxd/flows/main}{}

%% default parameters for ids
\pgfkeyssetvalue{/pktxd/default}{}
\pgfkeyssetvalue{/pktxd/default/opacity}{1}

%% can not use \foreach since it creates a local scope! :-(
\newcommand{\pktxd@sethides}[1]{
  \pgfkeyssetvalue{/pktxd/flows/#1/opacity}{0}
%  \foreach \x in { #1 } {
%    \pgfkeyssetvalue{/pktxd/flows/\x/opacity}{0}
%  }
}

\newcommand{\pktxd@setignore}[1]{\pgfkeyssetvalue{/pktxd/flows/#1/ignore}{1}}
\newif\ifpktxd@ignore

\newcommand{\pktxd@setfade}[1]{
  \pgfkeyssetvalue{/pktxd/flows/#1/opacity}{\pgfkeysvalueof{/pktxd/fade value}}}

%%%%%% styles

%% define a style: name to set of options
\newcommand{\definestyle}[2]{
  \pgfkeys{/pktxd/styles/#1/.style={#2}}}

%% make #1 (dynamically) inherit #2, adding #3 options
\newcommand{\derivestyle}[3]{
  \definestyle{#1}{/pktxd/styles/#2,#3}}

%% give a style to a flow
\newcommand{\setflowstyle}[2]{
  \pgfkeys{/pktxd/flows/#1/style/.initial=#2}}

\newcommand{\setflowlabelstyle}[2]{
  \pgfkeys{/pktxd/flows/#1/labelstyle/.initial=#2}}

%% the default style
%% removed the >=latex, since it does not obey opacity=...
\definestyle{default}{very thick, ->}

\definestyle{labeldefault}{above,sloped}

\pgfkeys{/pktxd/styles/thislabel/.style={}}
\pgfkeys{/pktxd/label style/.code=\pgfkeys{/pktxd/styles/thislabel/.style={{#1}}}}

%%%%%% various definitions

% this will be usefull for creating entities in a \foreach...
\def\pgfglobalkeys#1{
  \begingroup \ifnum
    \the\globaldefs>0\relax 
  \else
    \globaldefs=1\fi
  \pgfkeys{#1}\endgroup}

% loop on entities: arg is code using \e
\newcommand{\pktxd@forallentities}[1]{
  \@for\e:=\pktxd@entities\do{
    \if\e\relax\else #1\fi
  }
}

\newcommand{\pktxd@createentity}[1]{
  \xdef\pktxd@entities{#1,\pktxd@entities}
  \pgfglobalkeys{/pktxd/entities/#1/pos/.initial=0cm}   % space position
  \pgfglobalkeys{/pktxd/entities/#1/Tsend/.initial=0cm} % send time
  \pgfglobalkeys{/pktxd/entities/#1/Trecv/.initial=0cm} % recv time
  \pgfglobalkeys{/pktxd/entities/#1/Tmax/.initial=0cm}  % max time
  \pktxd@createtimer{#1}{l}{1}
  \pktxd@createtimer{#1}{l}{2}
  \pktxd@createtimer{#1}{r}{1}
  \pktxd@createtimer{#1}{r}{2}
}

\newcommand{\pktxd@createtimer}[3]{ % entity l/r id
  \pgfglobalkeys{/pktxd/entities/#1/timer/#2/#3/active/.initial=0}
  \pgfglobalkeys{/pktxd/entities/#1/timer/#2/#3/cancel/.initial=0}
  \pgfglobalkeys{/pktxd/entities/#1/timer/#2/#3/label/.initial=0}
  \pgfglobalkeys{/pktxd/entities/#1/timer/#2/#3/start/.initial=0}
  \pgfglobalkeys{/pktxd/entities/#1/timer/#2/#3/end/.initial=0}}

\pgfkeys{/pktxd/default/timers/l/1/offset/.initial=4mm}
\pgfkeys{/pktxd/default/timers/l/2/offset/.initial=9mm}
\pgfkeys{/pktxd/default/timers/r/1/offset/.initial=4mm}
\pgfkeys{/pktxd/default/timers/r/2/offset/.initial=9mm}

\newcommand{\pktxd@pos}[1]{\pgfkeysvalueof{/pktxd/entities/#1/pos}}
\newcommand{\pktxd@Tsend}[1]{\pgfkeysvalueof{/pktxd/entities/#1/Tsend}}
\newcommand{\pktxd@Trecv}[1]{\pgfkeysvalueof{/pktxd/entities/#1/Trecv}}

%% beware of 'macro sharing': we use setvalue here!
%% (note how we use pgfkeyslet in \pktxd@frame)
\newcommand{\pktxd@setTsend}[2]{\pgfkeyssetvalue{/pktxd/entities/#1/Tsend}{#2}}
\newcommand{\pktxd@setTrecv}[2]{\pgfkeyssetvalue{/pktxd/entities/#1/Trecv}{#2}}
\newcommand{\pktxd@letTsend}[2]{\pgfkeyslet{/pktxd/entities/#1/Tsend}{#2}}

%% if the pgfkey is defined in entity dir, use it
%% otherwise use value in default dir

\newcommand{\pktxd@getconftimer}[4]{
  \pgfkeysifdefined{/pktxd/entities/#1/timers/#2/#3/#4}
  {\pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/#4}}
  {\pgfkeysvalueof{/pktxd/default/timers/#2/#3/#4}}}

\newcommand{\pktxd@gettimerstart}[3]{
  \pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/start}}
\newcommand{\pktxd@gettimerend}[3]{
  \pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/end}}


%\pgfkeys{/pgf/key filter handlers/log/.install key filter handler}

\newlength{\pktxd@prop}\setlength{\pktxd@prop}{0.5cm}
\newlength{\pktxd@savedprop}
\newlength{\pktxd@trans}\setlength{\pktxd@trans}{2cm}
\newlength{\pktxd@savedtrans}  %% to keep default value accross frames
\newlength{\pktxd@latev}       %% amount of lateness if pktxd@latetrue


%% Draw a frame label: it can be made of:
%%  - l1 label (passed as arg to commands)
%%  - the l2 label (passed as label2 option key)
%%  - both

\newcommand{\pktxd@nodelabel}[2][1]{ % 1/-1, l1 label
  \ifpktxd@showlabelii\ifpktxd@hidelabel\itshape \pgfkeysvalueof{/pktxd/label2}\else
  \ifnum #1=1
  \begin{tabular}{c}
    \itshape \pgfkeysvalueof{/pktxd/label2}\\%[-3pt]
    #2
%    #2 \\[-3pt]
%    \if#2\empty\else#2 \\[-3pt]\fi
  \end{tabular}\else
  \begin{tabular}{c} % for A in hpktxd@, we want label2 to be below
    #2 \\
    \itshape \pgfkeysvalueof{/pktxd/label2}
  \end{tabular}\fi
  \fi\else\ifpktxd@hidelabel{}\else#2\fi\fi}

\newlength{\pktxd@len}

%% the draw arrow macro for vertical packet exchange diagram

% #1 are keys, #2 is sender pos, #3 is receiver pos
% #4 is send time, #5 is label

\newcommand{\pktxd@arrowv}[5][]{
  \pgfkeysifdefined{/pktxd/flows/\pktxd@id/labelstyle}
  {\def\labelstyle{/pktxd/styles/\pgfkeysvalueof{/pktxd/flows/\pktxd@id/labelstyle}}}
  {\def\labelstyle{/pktxd/styles/labeldefault}}
  \def\thisls{/pktxd/styles/thislabel}

  % tex does not honor arithmetic priorities... pgfmath does.
  \pgfmathsetlength{\pktxd@len}{#3-#2}
  \pgfmathsetmacro{\sign}{#2<#3?1:-1}

  \begin{scope}[/pktxd/.cd,#1]
    % iflost, draw only half way
    \ifpktxd@lost\def\lost{2}\else\def\lost{1}\fi
    % ifbad, draw a zigzag
    \ifpktxd@bad
       % can't be both bad and late
       \ifpktxd@late \pktxd@error{Frame both bad and late}
                                 {Sorry, a frame currently can't be both late and lost.}
       \else

       \draw (#2,-#4) --++(\pktxd@len/\lost/3,-\pktxd@prop/\lost/3)

                 \ifpktxd@sync\else node[align=center,near end,\labelstyle,\thisls]{\pktxd@nodelabel{#5}}\fi
    
                 decorate[decoration=zigzag,segment length=2mm]
                 {--++(\pktxd@len/\lost/3,-\pktxd@prop/\lost/3)
                   \ifpktxd@sync node[align=center,midway,\labelstyle,\thisls]{\pktxd@nodelabel{#5}}\fi}

                 --++(\pktxd@len/\lost/3,-\pktxd@prop/\lost/3);
                   \ifpktxd@lost\ifpktxd@crosslost \draw[-]
                   (\sign*2mm,-#4-\pktxd@prop/2)node{\Large $\times$}\fi\fi;
       \fi
    \else
    % iflate, use control points (lost not accepted)
    \ifpktxd@late
       \ifpktxd@lost \pktxd@error{Frame both late and lost}
                                 {A frame can't be both late and lost.}
       \else
       \draw (#2,-#4) 
       .. controls (#2/2+#3/2,-#4-\pktxd@prop/2) and (#2/2+#3/2,-#4-\pktxd@latev)
       .. (#3, -#4-\pktxd@latev-\pktxd@prop)
                   node[align=center,\labelstyle,\thisls,pos=0.1]{\pktxd@nodelabel{#5}};

       \fi
    \else
    % not bad, not late
       \draw (#2,-#4) -- ++(\pktxd@len/\lost,-\pktxd@prop/\lost)
                   node[align=center,\ifpktxd@sync midway\else near
                   start\fi,\labelstyle,\thisls]{\pktxd@nodelabel{#5}};
                   \ifpktxd@lost\ifpktxd@crosslost \draw[-]
                   (\sign*2mm,-#4-\pktxd@prop/2)node{\Large $\times$}\fi\fi;
    \fi
    \fi
  \end{scope}
}

%% the draw arrow macro for horizontal packet exchange diagram

\newcommand{\pktxd@arrowh}[5][]{
  \pgfkeysifdefined{/pktxd/flows/\pktxd@id/labelstyle}
  {\def\labelstyle{/pktxd/styles/\pgfkeysvalueof{/pktxd/flows/\pktxd@id/labelstyle}}}
  {\def\labelstyle{/pktxd/styles/labeldefault}}
  \def\thisls{/pktxd/styles/thislabel}

  \pgfmathsetlength{\pktxd@len}{#2-#3}
  \pgfmathtruncatemacro{\sign}{#2<#3?1:-1}

  \begin{scope}[/pktxd/.cd,#1,|-|]
  \ifnum \sign>0\def\toto{above}\else\def\toto{below}\fi
  \ifpktxd@lost\def\lost{2}\else\def\lost{1}\fi
  % first draw 'transmission time' line
  \ifpktxd@bad

       \draw (#4,#3) --++(\pktxd@trans/3,0)
                 decorate[decoration=zigzag,segment length=2mm]
                 {--++(\pktxd@trans/3,0) node[align=center,\labelstyle,\thisls,\toto=1mm,midway]{\pktxd@nodelabel[\sign]{#5}}}
                 --++(\pktxd@trans/3,0);
  \else
       \draw (#4,#3) -- ++(\pktxd@trans,0)
           node[align=center,\labelstyle,\thisls,\toto=1mm,midway]{\pktxd@nodelabel[\sign]{#5}};
  \fi
  % then draw 'propagation time' arrow
  \draw[thin,->] (#4+\pktxd@trans,#3) -- ++ (\pktxd@prop/\lost,\pktxd@len/\lost);
  \ifpktxd@lost\ifpktxd@crosslost \draw[-]
        (#4+\pktxd@trans+\pktxd@prop/2,\sign*-2mm) node{\Large $\times$}\fi\fi;
  \end{scope}
}


\newcommand{\pktxd@addtosend}[2]{
  \pgfmathsetlengthmacro\temp{\pktxd@Tsend{#1}+#2}
  \pgfkeyslet{/pktxd/entities/#1/Tsend}{\temp}}

\newcommand{\pktxd@addtorecv}[2]{
  \pgfmathsetlengthmacro\temp{\pktxd@Trecv{#1}+#2}
  \pgfkeyslet{/pktxd/entities/#1/Trecv}{\temp}}


%% the main macro for drawing a frame:
%% - handle all frame keys (prop, trans, delayed, late...)
%% - draw frame
%% - setup timers
%% - draw notes
%% - udpate time positions

\newcommand{\pktxd@frame}[4][]{ % [#1 keys], #2 sender, #3 receiver #4 label
  \edef\sendpos{\pgfkeysvalueof{/pktxd/entities/#2/pos}}
  \edef\recvpos{\pgfkeysvalueof{/pktxd/entities/#3/pos}}
  \edef\Tsend{\pgfkeysvalueof{/pktxd/entities/#2/Tsend}}

  % which side are timers and send notes on?
  \edef\align{\ifdim\sendpos<\recvpos l\else r\fi}

  \setlength{\pktxd@savedtrans}{\pktxd@trans}
  \setlength{\pktxd@savedprop}{\pktxd@prop}
  \pgfkeys{/pktxd/global/.activate family}
  \pgfkeysfiltered{/pktxd/.cd,#1}
  \pgfkeysgetvalue{/pktxd/id}{\pktxd@id}

  % if flow has 'ignore' set, we're done
  \pgfkeysifdefined{/pktxd/flows/\pktxd@id/ignore}{\pktxd@ignoretrue}{\pktxd@ignorefalse}
  \ifpktxd@ignore\else

  \pktxd@settrans{#4}

  \ifpktxd@delayed
    \pktxd@debug{delayed: len \pktxd@delayedlen ~ label \pktxd@delayedlabel ~ id \pktxd@delayedid}
    \edef\Trecv{\pgfkeysvalueof{/pktxd/entities/#2/Trecv}}

    \pktxd@starttimer{#2}{\align}{\pktxd@delayedid}{\Trecv}{\pktxd@delayedlen}{\pktxd@delayedlabel}
    \pktxd@setTsend{#2}{\Trecv}%%%
    \pktxd@addtosend{#2}{\pktxd@delayedlen}
    \edef\Tsend{\pgfkeysvalueof{/pktxd/entities/#2/Tsend}}
    \pktxd@endtimer{#2}{\align}{\pktxd@delayedid}
    \pktxd@delayedfalse
  \fi

  \ifpktxd@stop
    \pktxd@debug{stop: len \pktxd@stoplen ~ label \pktxd@stoplabel ~delay \pktxd@stopdelay ~ id \pktxd@stopid}
    \edef\Trecv{\pgfkeysvalueof{/pktxd/entities/#2/Trecv}}
    \pktxd@starttimer{#2}{\align}{\pktxd@stopid}{\Trecv}{\pktxd@stoplen}{\pktxd@stoplabel}
    \pktxd@setTsend{#2}{\pktxd@Trecv{#2}}
    \pktxd@addtosend{#2}{\pktxd@stopdelay}
    \edef\Tsend{\pgfkeysvalueof{/pktxd/entities/#2/Tsend}}
    \pktxd@canceltimer{#2}{\align}{\pktxd@stopid}{\Tsend}
    \pktxd@stopfalse
  \fi

  % process timed/timed2 args
  \@for\timed:=\pktxd@timeds\do{\expandafter\pktxd@processtimed\timed:#2}
  \def\pktxd@timeds{0/0/0}

  % set styles
  \pgfkeysifdefined{/pktxd/flows/\pktxd@id/style}{
    \def\thestyle{/pktxd/styles/\pgfkeysvalueof{/pktxd/flows/\pktxd@id/style}}}{
    \def\thestyle{/pktxd/styles/default}}
  \def\opa{\pktxd@getconf{\pktxd@id}{opacity}}
  
  % draw send note
  \ifpktxd@snote
  \pktxd@note[\thestyle,opacity=\opa]{\Tsend}{\sendpos}{\align}{s}{\pktxd@snoteoffset}{\pktxd@snote}
  \fi
  % draw frame
  \pktxd@arrow[#1,\thestyle,opacity=\opa]{\sendpos}{\recvpos}{\Tsend}{#4}
  % update times
  \pgfmathsetlengthmacro\Trecv{\Tsend+\pktxd@prop+\pktxd@trans}
  \pgfmathsetlengthmacro\Tsend{\Tsend+\pktxd@trans+\pktxd@spacesame}
  % draw receive note
  \ifpktxd@rnote
  \pktxd@note[\thestyle,opacity=\opa]{\Trecv-\pktxd@latev}{\recvpos}
             {\if\align rl\else r\fi}{r}{\pktxd@rnoteoffset}{\pktxd@rnote}
  \fi

  \edef\Tcancel{\Trecv}
  \ifpktxd@late
    % no simpler way to _copy_ the length value?
    \pgfmathsetlengthmacro\Tcancel{\Trecv+\pktxd@latev}
    \pgfkeyslet{/pktxd/values/#3/\pktxd@latename}{\Tcancel}
    \pktxd@latefalse
    \setlength\pktxd@latev{0mm}
  \fi

  % restore values
  \pgfkeyssetvalue{/pktxd/id}{main}
  \setlength{\pktxd@trans}{\pktxd@savedtrans}
  \setlength{\pktxd@prop}{\pktxd@savedprop}
  \pktxd@snotefalse
  \pktxd@rnotefalse

  % commit time updates
  \pgfkeyslet{/pktxd/entities/#2/Tsend}{\Tsend}
  \pgfkeyslet{/pktxd/entities/#3/Trecv}{\Trecv}

  % update Tmax (Tcancel set above to Trecv + pktxd@latev)
  \ifdim\Tcancel>\pgfkeysvalueof{/pktxd/entities/#3/Tmax}
  \pgfkeyslet{/pktxd/entities/#3/Tmax}{\Tcancel}
  \fi

  \ifpktxd@sync
    \pgfmathsetlengthmacro\Tsndr{\Trecv+\pktxd@spaceother}
    \pgfkeyslet{/pktxd/entities/#3/Tsend}{\Tsndr}
  \fi

  % process cancel/cancel2 args
  \@for\id:=\pktxd@cancels\do{
    \if 0\id\else
    \pktxd@debug{cancel \id}
    \pktxd@canceltimer{#3}{\if l\align r\else l\fi}{\id}{\Tcancel}
    \fi}
  \def\pktxd@cancels{0}

  \fi %pktxd@ignore
}


%%%%%% handling of timers

\newif\ifpktxd@putlabelonarrow
\newlength{\pktxd@labellength}
\newlength{\pktxd@temp}

% entity, start time, end time, cancel time (or x), label, pos offset,
% arrow style, label style
% TODO include cancel arrow style?

\newcommand{\pktxd@drawtimer}[8]{
  \pktxd@debug{drawtimer #1, #2/#3/#4 #5 #6}

  % @putlabelonarrow will be set if 'timer label on arrow' is set
  % and label is not too wide
  \pktxd@putlabelonarrowfalse
  \ifpktxd@timeronarrow
    \settowidth{\pktxd@labellength}
      %% need this to use settowidth in tikzpicture
      {\pgfinterruptpicture#5\endpgfinterruptpicture}  %% should use #8?
    \addtolength{\pktxd@labellength}{\pktxd@timerlabeladd}
    \pgfmathsetlength\pktxd@temp{#3-#2}
    \ifdim\pktxd@labellength<\pktxd@temp
      \pktxd@putlabelonarrowtrue
    \fi
  \fi

  % pos is entity pos + offset
  % get side from offset sign
  \def\entitypos{\pktxd@pos{#1}}
  \def\offset{#6}
  \def\side{\ifdim#6<0cm l\else r\fi}
  \def\pos{
    \ifpktxd@h
       -\entitypos-\offset
    \else
       \entitypos+\if\side r                \offset\else
                  \ifpktxd@timerleftbelow   \offset\else
                  \ifpktxd@timerleftbottomup\offset\else
                  \ifpktxd@putlabelonarrow  \offset\else
                                            \offset-3mm
                  \fi\fi\fi\fi
    \fi}

  \ifpktxd@putlabelonarrow
     \def\above{/pktxd/fill}
  \else
  \ifpktxd@h\def\above{above}\else
    %% get label orientation for v diagrams
    %% the timer label is placed above except if:
    %% - it's a left timer and @timerleftbelow is set (placed below)
    %% - it's a left timer and @timerleftbottomup is set (placed above +
    %% rotate).  We use /pktxd/reverse in this case cause we don't know
    %% how to pass two keys in a single macro... -> expandafter?
    \if\side r\def\above{above}\else
    \ifpktxd@timerleftbelow\def\above{below}\else
    \ifpktxd@timerleftbottomup\def\above{/pktxd/reverse}\else
    \def\above{above}\fi
    \fi\fi
  \fi\fi

  % for h diagrams, need an additionnal offset
  % TODO: should be configurable (haddoffset)

  \edef\timerhoffset{\if\side r
    % side r
    \if#1\ifpktxd@reversed A\else B\fi
    \ifpktxd@putlabelonarrow 4mm\else 7mm\fi\else 3mm\fi\else
    % side l
    \if#1\ifpktxd@reversed B\else A\fi-3mm\else 0mm\fi\fi}

  \if x#4 % no cancel
    \ifpktxd@h
      \draw[thin,<->,#7] (#2,\pos-\timerhoffset)
           -- (#3,\pos-\timerhoffset) node[midway,sloped,\above,#8]{#5};
    \else
      \draw[thin,<->,#7] (\pos,-#2-\pktxd@timertoffset)
           -- (\pos,-#3+\pktxd@timertoffset) node[midway,sloped,\above,#8]{#5};
    \fi
  \else % including a cancel
    \ifpktxd@h
      \draw[thin,#7](#2,\pos-\timerhoffset) -- (#4,\pos-\timerhoffset);
      \draw[thin,dotted,<->,#7](#2,\pos-\timerhoffset)
           -- (#3,\pos-\timerhoffset) node[midway,sloped,\above,#8]{#5};
    \else
      \draw[thin,#7](\pos,-#2-\pktxd@timertoffset)
              -- (\pos,-#4);
      \draw[thin,dotted,<->,#7](\pos,-#2-\pktxd@timertoffset)
           -- (\pos,-#3+\pktxd@timertoffset) node[midway,sloped,\above,#8]{#5};
    \fi
  \fi
}


%% so that arrows of consecutive timers are spaced a very little bit
\newlength{\pktxd@timertoffset}\setlength{\pktxd@timertoffset}{0.2mm}
\pgfkeys{/pktxd/timer time offset/.code=\setlength{\pktxd@timertoffset}{#1}}

\newcommand{\pktxd@endtimerifactive}[3]{
  \if\pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/active}t
  \pktxd@endtimer{#1}{#2}{#3}\fi}

%% timer h position: based on hpos, l/r alignment and offset
%% in horizontal, hpos is negated (left/- is up/+)
%% in vertical, remove 3mm to l timers if neither @timerleftbelow nor
%% @timerleftbottomup is set

\newcommand{\pktxd@settimerhpos}[4]{ % entity/lr/id macro
  \pktxd@debug{timerhpos #1/#2/#3}
  \def\pos{\pktxd@pos{#1}}
  \def\offset{\pktxd@getconftimer{#1}{#2}{#3}{offset}}
  \def#4{%
  \ifpktxd@h-\pos+\if #2r-\offset\else\offset\fi
  \else
  \pos+\if #2r\offset\else\ifpktxd@timerleftbelow-\offset\else\ifpktxd@timerleftbottomup-\offset
  \else-\offset-3mm\fi\fi\fi\fi}}

\newcommand{\pktxd@starttimer}[6]{ % entity, l/r, id, starttime, len, label
  \pktxd@endtimerifactive{#1}{#2}{#3}
  \pgfkeyssetvalue{/pktxd/entities/#1/timers/#2/#3/active}{t}
  \pgfkeyssetvalue{/pktxd/entities/#1/timers/#2/#3/cancel}{0}
  \def\timeroffset{\pktxd@getconftimer{#1}{#2}{#3}{offset}}
  \pgfkeyslet{/pktxd/entities/#1/timers/#2/#3/start}{#4}
  \pgfmathsetlengthmacro\temp{#4+#5}
  \pgfkeyslet{/pktxd/entities/#1/timers/#2/#3/end}{\temp}
  \pgfkeyssetvalue{/pktxd/entities/#1/timers/#2/#3/label}{#6}

  \pktxd@debugtimer{starttimer}{#1}{#2}{#3}
}

\newcommand{\pktxd@debugtimer}[4]{
  \pktxd@debug{#1 timer #2/#3/#4}
  \pktxd@debug{start \pktxd@gettimerstart{#2}{#3}{#4}}
  \pktxd@debug{end   \pktxd@gettimerend{#2}{#3}{#4}}
}

\newcommand{\pktxd@canceltimer}[4]{ % entity, l/r, id, time
  \pktxd@debugtimer{canceltimer #4}{#1}{#2}{#3}
  \pgfkeyssetvalue{/pktxd/entities/#1/timers/#2/#3/active}{0}
  \pgfkeyssetvalue{/pktxd/entities/#1/timers/#2/#3/cancel}{t}
  \def\timerstart{\pktxd@gettimerstart{#1}{#2}{#3}}
  \def\timerend{\pktxd@gettimerend{#1}{#2}{#3}}
  \def\timeroffset{\if#2l-\fi\pktxd@getconftimer{#1}{#2}{#3}{offset}}

  \pktxd@settimerhpos{#1}{#2}{#3}{\hpos}

  \ifdim#4>\timerend % check cancelling is indeed possible
    \ifpktxd@h
      \node at (#4,\hpos)[draw,red,fill=yellow]{Cancel expired timer!};
    \else
      \node at (\hpos,-#4)[draw,red,fill=yellow]{Cancel expired timer!};
    \fi
      \pktxd@drawtimer{#1}{\timerstart}{\timerend}{x}
        {\pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/label}}
        {\timeroffset}{}{}
      \pktxd@drawtimer{#1}{\timerend}{#4}{x}{}
        {\timeroffset}{dotted,red,->}{}
      \pktxd@error{Your're trying to cancel an expired timer}
        {A prominent yellow box has been drawn to show where the cancel
        was requested.}

  \else              % all right
    \pktxd@drawtimer{#1}{\timerstart}{\timerend}{#4}
        {\pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/label}}{\timeroffset}{}{}
  \fi
}

%% finish drawing a timer
\newcommand{\pktxd@endtimer}[3]{
  \pgfkeyssetvalue{/pktxd/entities/#1/timers/#2/#3/active}{0}
  \pgfkeyssetvalue{/pktxd/entities/#1/timers/#2/#3/cancel}{0}
  \def\timerstart{\pktxd@gettimerstart{#1}{#2}{#3}}
  \def\timerend{\pktxd@gettimerend{#1}{#2}{#3}}
  \def\timeroffset{\if#2l-\fi\pktxd@getconftimer{#1}{#2}{#3}{offset}}
  
  \pktxd@drawtimer{#1}{\timerstart}{\timerend}{x}
    {\pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/label}}{\timeroffset}{}{}
}

\newcommand{\pktxd@getconf}[2]{
  \pgfkeysifdefined{/pktxd/flows/#1/#2}
  {\pgfkeysvalueof{/pktxd/flows/#1/#2}}
  {\pgfkeysvalueof{/pktxd/default/#2}}}

\newcommand{\pktxd@note}[7][]{ % [keys], timepos, hpos, l/r, s/r, offset, note
  \pktxd@debug{note: #2 #3 #4 #5 #6 } % #7 fails if multi-line
  \ifpktxd@h
  % is the note going up or down?
  \edef\orient{\if#5s\if#4 ru\else d\fi\else\if#4 ld\else u\fi\fi}
  % a sent if offset to the right, a recv to the left
  \edef\dpos{\if#5s 2mm\else-2mm\fi}
  \if\orient d   % down
    \node[rotate=-90,#1] at (#2+\dpos, -#3\if#5r-\else+\fi 10mm) { #7 };
  \else          % up
    \node[rotate=90,#1] at (#2+\dpos, -#3\if#5r+\else-\fi 10mm) { #7 };
  \fi
  \else % vertical diagram
  \if#4l
    \node[align=right,left,#1] at (#3-#6, -#2) { #7 };
  \else
    \node[align=left,right,#1] at (#3+#6, -#2) { #7 };
  \fi\fi}


%%%%%% side decorations (eg for TCP)

\newcommand{\pktxd@action}[4]{ % timepos, hpos, l/r, text
  \ifpktxd@h\else
  \if#3l\def\align{left}\else\def\align{right}\fi
  \draw[<-](#2+\if#3l-\pktxd@actionoffset\else\pktxd@actionoffset\fi,-#1+\pktxd@actiontimeoffset)
           -- ++(\if#3l180\else0\fi:\pktxd@actionlength) node[\align]{#4};
  \fi}

\newcommand{\pktxd@state}[4]{ % timepos, hpos, l/r, text
  \ifpktxd@h\else
  \if#3l\def\align{left}\else\def\align{right}\fi
  \draw(#2+\if#3l-\pktxd@stateoffset\else\pktxd@stateoffset\fi,-#1)
       node[draw,\align]{\textsc{#4}};
  \fi}

\newcommand{\Astate}[1]{\pktxd@state{\pAs}{\pktxd@pos{A}}{l}{#1}}
\newcommand{\Bstate}[1]{\pktxd@state{\pBs}{\pktxd@pos{B}}{r}{#1}}

\newcommand{\Aactionstate}[2]{
  \pktxd@action{\pAs}{\pktxd@pos{A}}{l}{#1}
  \pktxd@state{\pAs-5mm}{\pktxd@pos{A}}{l}{#2}}

\newcommand{\Bactionstate}[2]{
  \pktxd@action{\pBs}{\pktxd@pos{B}}{r}{#1}
  \pktxd@state{\pBs-5mm}{\pktxd@pos{B}}{r}{#2}}


%% laters -- unlimited number

\newlength{\pktxd@laterdashedlen}
\setlength{\pktxd@laterdashedlen}{1cm}
\pgfkeys{/pktxd/laters/.initial={0cm/0cm}}

\newcommand{\later}[1]{
  \pgfkeys{/pktxd/laters/.append/.expanded={,\pAs/#1}}
  \pktxd@addtosend{A}{#1}
  \pktxd@addtorecv{A}{#1}
  \pktxd@addtosend{B}{#1}
  \pktxd@addtorecv{B}{#1}
}

\newcommand{\pktxd@flushtimer}[3]{
  \if\pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/active}t
    \pktxd@endtimer{#1}{#2}{#3}
    \pktxd@waittimer{#1}{#2}{#3}
  \else
    \if\pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/cancel}t
      \pktxd@debugtimer{flush/cancel}{#1}{#2}{#3}
      \pktxd@debug{pos#1 = \pktxd@Tsend{#1}}
      \pktxd@waittimer{#1}{#2}{#3}
      \pktxd@debug{updated pos#1 = \pktxd@Tsend{#1}}
  \fi\fi}

\newcommand{\pktxd@alltimers}[1]{
  \foreach \e/\o in {A/l,B/r} {
    \foreach \n in {1,2} {
      #1{\e}{\o}{\n}
      }
    }
  }

\newcommand{\pktxd@finishtimers}{
  \pktxd@forallentities{
    \pktxd@flushtimer{\e}{l}{1}
    \pktxd@flushtimer{\e}{l}{2}
    \pktxd@flushtimer{\e}{r}{1}
    \pktxd@flushtimer{\e}{r}{2}
    }
  }

% warning: uses \tpos (dynamic scope?)
\newcommand{\pktxd@drawlateronetimer}[3]{
  \pktxd@settimerhpos{#1}{#2}{#3}{\hpos}
  \draw[graphicbackground,dashed] (\hpos,\tpos) -- ++(0,\pktxd@laterdashedlen);}

% draw one later: erase part of the vertical lines
% starttime len
\newcommand{\pktxd@drawlater}[2]{
  \def\tpos{-#1-#2/2-\pktxd@laterdashedlen/2}

  % vertical lines
  \ifpktxd@h\else
  \draw[graphicbackground,dashed](\pktxd@pos{A},\tpos) -- ++(0,\pktxd@laterdashedlen);
  \draw[graphicbackground,dashed](\pktxd@pos{B},\tpos) -- ++(0,\pktxd@laterdashedlen);
  \fi

  % timer lines
  \ifpktxd@h\else
  \pktxd@alltimers{\pktxd@drawlateronetimer}
  \fi
}

\newcommand{\pktxd@setpos}[2]{
  \pgfmathsetlengthmacro{\toto}{#2}
  \pgfkeyslet{/pktxd/entities/#1/pos}{\toto}}


\newcommand{\wait}[2][1cm]{\pktxd@addtosend{#2}{#1}}

%%: X waits for Y, Y waits for X (usefull only in fullduplex mode)

\newcommand{\XwaitY}[2]{
  \edef\temp{\pktxd@Trecv{#1}}
  \pktxd@letTsend{#1}{\temp}
  \pktxd@debug{Xwait temp=\temp Tsend=\pktxd@Tsend{#1}}
  \pktxd@addtosend{#1}{\pktxd@spaceother}}

%% set Tsend to end of the timer if it's later
\newcommand{\pktxd@waittimer}[3]{
  \edef\timerend{\pktxd@gettimerend{#1}{#2}{#3}}
  \edef\Tsend{\pktxd@Tsend{#1}}
  \ifdim \Tsend<\timerend\pktxd@letTsend{#1}{\timerend}\fi
}


%%% specialized code for two entities diagrams

\def\timerAend {\pktxd@gettimerend{A}{l}{1}}
\def\timerAiend{\pktxd@gettimerend{A}{l}{2}}
\def\timerBend {\pktxd@gettimerend{B}{r}{1}}
\def\timerBiend{\pktxd@gettimerend{B}{r}{2}}

\def\timerAoffset {\pgfkeysvalueof{/pktxd/default/timers/l/1/offset}}
\def\timerAioffset{\pgfkeysvalueof{/pktxd/default/timers/l/2/offset}}
\def\timerBoffset {\pgfkeysvalueof{/pktxd/default/timers/r/1/offset}}
\def\timerBioffset{\pgfkeysvalueof{/pktxd/default/timers/r/2/offset}}

% time, len, label
\newcommand{\settimerA} [3]{\pktxd@starttimer{A}{l}{1}{#1}{#2}{#3}}
\newcommand{\settimerAi}[3]{\pktxd@starttimer{A}{l}{2}{#1}{#2}{#3}}
\newcommand{\settimerB} [3]{\pktxd@starttimer{B}{r}{1}{#1}{#2}{#3}}
\newcommand{\settimerBi}[3]{\pktxd@starttimer{B}{r}{2}{#1}{#2}{#3}}

\newcommand{\pktxd@endtimerA} {\pktxd@endtimer{A}{l}{1}}
\newcommand{\pktxd@endtimerAi}{\pktxd@endtimer{A}{l}{2}}
\newcommand{\pktxd@endtimerB} {\pktxd@endtimer{B}{r}{1}}
\newcommand{\pktxd@endtimerBi}{\pktxd@endtimer{B}{r}{2}}

\newcommand{\canceltimerA}[1] {\pktxd@canceltimer{A}{l}{1}{#1}}
\newcommand{\canceltimerAi}[1]{\pktxd@canceltimer{A}{l}{2}{#1}}
\newcommand{\canceltimerB}[1] {\pktxd@canceltimer{B}{r}{1}{#1}}
\newcommand{\canceltimerBi}[1]{\pktxd@canceltimer{B}{r}{2}{#1}}

%%: A sends to B, B sends to A

\newcommand{\AB}[2][]{\pktxd@frame[#1]{A}{B}{#2}}
\newcommand{\BA}[2][]{\pktxd@frame[#1]{B}{A}{#2}}

\newcommand{\Await}[1][1cm]{\wait[#1]{A}}
\newcommand{\Bwait}[1][1cm]{\wait[#1]{B}}

\newcommand{\AwaitB}{\XwaitY{A}{B}}
\newcommand{\BwaitA}{\XwaitY{B}{A}}

%%: arg is name set in the late frame ('name' key, defaults to lateframe)
\newcommand{\Awaitlate}[1][lateframe]{
  \pktxd@setTrecv{A}{\pgfkeysvalueof{/pktxd/values/A/#1}}
  \AwaitB}

\newcommand{\Bwaitlate}[1][lateframe]{
  \pktxd@setTrecv{B}{\pgfkeysvalueof{/pktxd/values/B/#1}}
  \BwaitA}
  

%%: A,B waits for its current timer to expire

\newcommand{\Awaittimer} {\pktxd@waittimer{A}{l}{1}}
\newcommand{\Awaittimeri}{\pktxd@waittimer{A}{l}{2}}
\newcommand{\Bwaittimer} {\pktxd@waittimer{B}{r}{1}}
\newcommand{\Bwaittimeri}{\pktxd@waittimer{B}{r}{2}}

%%: A sends a timed frame to B
% [keys], flabel, len, tlabel

\newcommand{\ABtimed} [4][]{\AB[#1,timed={#3}{#4}]{#2}}
\newcommand{\ABtimedi}[4][]{\AB[#1,timed2={#3}{#4}]{#2}}
\newcommand{\BAtimed} [4][]{\BA[#1,timed={#3}{#4}]{#2}}
\newcommand{\BAtimedi}[4][]{\BA[#1,timed2={#3}{#4}]{#2}}

%%: A sends a frame that cancels B's timer

\newcommand{\ABcancel} [2][]{\AB[cancel,#1]{#2}}
\newcommand{\ABcanceli}[2][]{\AB[cancel2,#1]{#2}}
\newcommand{\BAcancel} [2][]{\BA[cancel,#1]{#2}}
\newcommand{\BAcanceli}[2][]{\BA[cancel2,#1]{#2}}

%%: A sets a timer and sends a frame when it expires
%%  [keys], len, tlabel, flabel
\newcommand{\ABdelayed}[4][]{\AB[#1,delayed={#2}{#3}]{#4}}
\newcommand{\BAdelayed}[4][]{\BA[#1,delayed={#2}{#3}]{#4}}

%%: A sets a timer and after a delay sends a frame that cancels it
%%: typical use: ACK timer cancelled by sending of DATA
%%  [keys], len, tlabel, delay, flabel
\newcommand{\ABstop}[5][]{\AB[#1,stop={#2}{#3}{#4}]{#5}}
\newcommand{\BAstop}[5][]{\BA[#1,stop={#2}{#3}{#4}]{#5}}


%% shortcuts
\def\pAs{\pktxd@Tsend{A}}
\def\pBs{\pktxd@Tsend{B}}
\def\pAr{\pktxd@Trecv{A}}
\def\pBr{\pktxd@Trecv{B}}


%%%% intialize entities

\newcommand{\pktxd@entityname}[2]{\pgfglobalkeys{/pktxd/entities/#1/.initial=#2}}

% in two entities mode
\def\pktxd@initentities{
  \def\pktxd@entities{\relax}
  \pktxd@createentity{A}
  \pktxd@createentity{B}
  \def\pktxd@A{\ifpktxd@reversed B\else A\fi}
  \def\pktxd@B{\ifpktxd@reversed A\else B\fi}
  \pktxd@setpos{\pktxd@A}{-\pktxd@width/2}
  \pktxd@setpos{\pktxd@B}{\pktxd@width/2}
  \pktxd@debugentities{two mode}
}

% in multiple entities mode
\newlength{\currentpos}

\def\pktxd@initmentities#1{
  \gdef\pktxd@entities{\relax}
  \setlength{\currentpos}{0cm}
  \foreach \e/\n/\w in {#1} {
    \ifx\n\w\def\w{\pktxd@width}\fi
    \addtolength{\currentpos}{\w}
    \pktxd@debug{entity \e ~ name \n ~ width \w ~ position \the\currentpos}
    \pktxd@createentity{\e}
    \pgfglobalkeys{/pktxd/entities/\e/.initial/.expanded=\n}
    \pgfglobalkeys{/pktxd/entities/\e/pos/.initial/.expanded=\the\currentpos} 
    % see http://tex.stackexchange.com/questions/33125/tikz-foreach-and-sum
    % for some reason, we can't \global the \addtolength above
    \global\currentpos=\currentpos
  }
  \pktxd@debugentities{multiple mode}
  \pktxd@mmodetrue
}
    
\def\pktxd@debugentities#1{
  \pktxd@debug{entities: #1}
  \pktxd@forallentities {
    \edef\name{\pgfkeysvalueof{/pktxd/entities/\e}}
    \edef\pos{\pgfkeysvalueof{/pktxd/entities/\e/pos}}
    \pktxd@debug{entity: \e/\name/\pos}
  }}


% compute the maximum time of all entities
% arg is added offset to Trecv

\newcommand{\pktxd@computemaxtime}[1]{
  \def\maxtime{0pt}
  \pktxd@forallentities{
    % if full-duplex we consider the Tsend, else Trecv+#1 (@spaceother
    % for v diags)
    \ifpktxd@sync\edef\tsnd{\pgfkeysvalueof{/pktxd/entities/\e/Tsend}}\else
    \pgfmathsetlengthmacro\tsnd{
      \pgfkeysvalueof{/pktxd/entities/\e/Trecv}+#1}\fi
    % Tmax may still be below (late frames)
    \pgfmathsetlengthmacro\tmax{
      \pgfkeysvalueof{/pktxd/entities/\e/Tmax}+#1}
    \pktxd@debug{e=\e ~ maxtime=\maxtime ~ tsnd=\tsnd ~ tmax=\tmax}
    \ifdim \maxtime<\tsnd \edef\maxtime{\tsnd}\fi
    \ifdim \maxtime<\tmax \edef\maxtime{\tmax}\fi
  }
  \pktxd@debug{final maxtime=\maxtime}
}

%%%% user environments

\newenvironment{pktxdiag}[1][]{
  \newcommand{\fullduplex}{\pktxd@syncfalse}%
  \newcommand{\halfduplex}{\pktxd@synctrue}%
  \def\frame{\pktxd@frame}%
  \def\pktxd@arrow{\pktxd@arrowv}%
  \def\entityname{\pktxd@entityname}%
  %
  \pktxd@hfalse%
  \setlength{\pktxd@trans}{0cm}%
  \begin{tikzpicture}[/pktxd/.cd,#1]\sffamily
  \ifpktxd@mmode\else\pktxd@initentities\fi
  }
  {
    % finish drawing all timers
    % this also moves Tsend to end of timer if needed
    \pktxd@finishtimers

    % draw vertical lines and labels
    \pktxd@computemaxtime{\pktxd@spaceother}
    \pktxd@forallentities {
    \draw[thin](\pktxd@pos{\e},\pktxd@spacesame/2) node[align=center,above]{\pgfkeysvalueof{/pktxd/entities/\e}} -- (\pktxd@pos{\e},-\maxtime);
    }

    % draw later(s)
    \pgfkeys{/pktxd/laters/.get=\laters}
    \foreach \t/\l in \laters {
      %\pktxd@debug{time \t~ len \l}
      \ifdim\t=0cm\else\pktxd@drawlater{\t}{\l}\fi
    }

    % remove entities names
    % they are set through pgfglobalkeys and would persist accross envs
    \pktxd@forallentities {
      \pgfglobalkeys{/pktxd/entities/\e/.initial=\relax}
    }
  \end{tikzpicture}
}

\newenvironment{hpktxdiag}[1][]{
  \newcommand{\fullduplex}{\pktxd@syncfalse}%
  \newcommand{\halfduplex}{\pktxd@synctrue}%
  \def\frame{\pktxd@frame}%
  \def\pktxd@arrow{\pktxd@arrowh}%
  \def\entityname{\pktxd@entityname}%
  %
  \pktxd@htrue%
  \setlength{\pktxd@spacesame}{0cm}%
  \setlength{\pktxd@spaceother}{0cm}%
  \def\pktxd@width{1cm}%
  \setlength{\pktxd@prop}{3mm}%
  \begin{tikzpicture}[/pktxd/.cd,#1]\sffamily
  \ifpktxd@mmode
  \PackageError{pktxdiag}{Multi-entities mode not supported in h
    diagrams}{Multi-entities mode was triggered by use of 'entities'
    key.  This occured in a hpktxdiag environment, however horizontal
    diagrams do not support multi-entities mode.}
  \fi
  \pktxd@initentities
  }
  {
    % finish drawing all timers
    \pktxd@finishtimers

    % draw labels (we could do it at env opening)
    \pktxd@forallentities {
      \draw(-\pktxd@spacesame/2,-\pktxd@pos{\e}) node[align=center,left]{\pgfkeysvalueof{/pktxd/entities/\e}};
  }
  % add to the right margin to get centered picture
  \pktxd@computemaxtime{2mm}
  \draw(\maxtime,0) node {};

  % no need to remove names : /pktxd/A|B/.code sets them in env scope
  % (contrary to @initmentities)
\end{tikzpicture}}

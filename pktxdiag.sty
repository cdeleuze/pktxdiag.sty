\NeedsTeXFormat{LaTeX2e}[1994/06/01]
\ProvidesPackage{pktxdiag}[2024/03/30 Drawing packet exchange diagrams]

%% package setup

\DeclareOption{debug}{\pktxd@debugtrue}
\newif\ifpktxd@debug

% use PackageWarning rather than PackageError when canceling expired
% timers.  See also 'warn only' env option.
\DeclareOption{warnonly}{\pktxd@warnonlytrue}
\newif\ifpktxd@warnonly

\ProcessOptions

\RequirePackage{xstring} % \IfBeginWith in @settrans
\RequirePackage{tikz}
\usetikzlibrary{decorations.pathmorphing} % for drawing zigzag
\usetikzlibrary{arrows.meta}              % for arrow styles
\usetikzlibrary{backgrounds}              % for the diagram background

% entities have to be drawn below all other elements
\pgfdeclarelayer{entities}
\pgfsetlayers{background,entities,main}

\newcommand{\pktxd@error}[2]{
  \ifpktxd@warnonly\PackageWarning{pktxdiag}{#1}
  \else\PackageError{pktxdiag}{#1}{#2}
  \fi}

\newcommand{\pktxd@debug}[1]{
  \ifpktxd@debug\typeout{pktxd@debug: #1}\fi}

\def\pktxd@bgcolor{white}

% multiple entities mode?
% false globaly, set to true in env scope by 'entities' key
\newif\ifpktxd@mmode

\newif\ifpktxd@h  % is current env horizontal?

%% environment keys

\pgfkeys{/pktxd/.cd,
  %
  debug/.is if=pktxd@debug,
  warn only/.is if=pktxd@warnonly,
  background/.code=\def\pktxd@bgcolor{#1},
  %
  prop/.code=\setlength{\pktxd@prop}{#1},
  %
  no cross/.is if=pktxd@nocross,
  snoteoffset/.code=\def\pktxd@snoteoffset{#1},
  snoteoffset/.default=0,
  rnoteoffset/.code=\def\pktxd@rnoteoffset{#1},
  rnoteoffset/.default=0,
  noteoffset/.style={snoteoffset=#1,rnoteoffset=#1},
  %
  show label2/.is if=pktxd@showlabelii,
  hide label/.is if=pktxd@hidelabel,
}

\pgfkeys{/pktxd/.cd,
  entities/.code=\pktxd@initmentities{#1},
  initial delay/.code=\setlength{\pktxd@initialdelay}{#1},
  final delay/.code=\setlength{\pktxd@finaldelay}{#1},
  send delay/.code=\setlength{\pktxd@senddelay}{#1},
  reply delay/.code=\setlength{\pktxd@replydelay}{#1},
  full duplex/.code=\pktxd@syncfalse,
  width/.code=\def\pktxd@width{#1},
  pause/.code=\def\pktxd@pausedefault{#1},
  reversed/.is if=pktxd@reversed
}

\newlength{\pktxd@initialdelay}\setlength{\pktxd@initialdelay}{5mm}
\newlength{\pktxd@finaldelay}\setlength{\pktxd@finaldelay}{4mm}
\newlength{\pktxd@senddelay}\setlength{\pktxd@senddelay}{1cm}
\newlength{\pktxd@replydelay}\setlength{\pktxd@replydelay}{5mm}
\newif\ifpktxd@sync\pktxd@synctrue
\def\pktxd@width{2.75cm}
\def\pktxd@pausedefault{1cm}
\newif\ifpktxd@reversed

\pgfkeys{/pktxd/.cd,
  % in two-entities mode, these are valid options for env
  % (we cannot create them *inside* the env...)
  A/.code=\pgfkeyssetvalue{/pktxd/entities/A}{#1},
  A/.default=A,
  Apic/.code 2 args={\pgfkeyssetvalue{/pktxd/entities/A/pic}{\includegraphics[#2]{#1}}},
  B/.code=\pgfkeyssetvalue{/pktxd/entities/B}{#1},
  B/.default=B,
  Bpic/.code 2 args={\pgfkeyssetvalue{/pktxd/entities/B/pic}{\includegraphics[#2]{#1}}},
  pic on top/.is if=pktxd@picontop,
  pic offset/.code=\def\pktxd@picoffset{#1}
}

\newif\ifpktxd@picontop
\def\pktxd@picoffset{0mm}

%%% transmission time

% horizontal diagrams also show transmission time

% this is set to 0cm in vertical env
\newlength{\pktxd@trans}\setlength{\pktxd@trans}{2cm}

% by default frames whose label starts with ACK are short
% key 'no shorts' removes this rule
% key hdlc sets names for HDLC
% key shorts=list sets the names of short frames

\pgfkeys{/pktxd/.cd,
  trans/.default=10mm,
  trans/.code=\ifpktxd@h\setlength{\pktxd@trans}{#1}\fi,
  %
  hdlc/.code=\edef\pktxd@shorts{\pktxd@shortshdlc},
  shorts/.code=\def\pktxd@shorts{#1},
  no shorts/.code=\def\pktxd@shorts{}
}

\def\pktxd@shorts{ACK}
\def\pktxd@shortshdlc{RR,RNR,REJ,SREJ,SABM,DISC,UA}

\pgfkeyssetvalue{/pktxd/short trans}{7mm}

% sets value of \pktxd@trans based on label #1
\newcommand{\pktxd@settrans}[1]{
  \ifpktxd@h
  \def\pktxd@thistrans{\pktxd@trans}
  % command from xstring package
  % only the first line of multi line labels is considered
  % (otherwise, this crashes)
  \expandarg
  \foreach \x in \pktxd@shorts {
    \IfBeginWith{#1}{\x}{
      \gdef\pktxd@thistrans{\pgfkeysvalueof{/pktxd/short trans}}}
    {}
  }
  \setlength{\pktxd@trans}{\pktxd@thistrans}
  \fi
}

%% frame keys

\pgfkeys{/pktxd/frame/.cd,
  % these can also be set for the whole env
  % so we defined them as .style's
  %
  prop/.style={/pktxd/prop=#1},
  trans/.style={/pktxd/trans=#1},
  no cross/.style={/pktxd/no cross=#1},
  snoteoffset/.style={/pktxd/snoteoffset=#1},
  rnoteoffset/.style={/pktxd/rnoteoffset=#1},
  %
  % now the frame specific keys
  %
  fid/.code=\def\pktxd@fid{#1},
  lost/.is if=pktxd@lost,
  plop/.is if=pktxd@plop,
  gone/.is if=pktxd@gone,
  bad/.is if=pktxd@bad,
  late/.default=4cm,
  late/.code=\pktxd@latetrue\setlength{\pktxd@latev}{#1},
  name/.code=\def\pktxd@latename{#1}
  %
  timed/.value required,
  timed/.code 2 args=\pktxd@addtimed{1}{#1}{#2},
  timed2/.value required,
  timed2/.code 2 args=\pktxd@addtimed{2}{#1}{#2},
  timed3/.value required,
  timed3/.code 2 args=\pktxd@addtimed{3}{#1}{#2},
  timed4/.value required,
  timed4/.code 2 args=\pktxd@addtimed{4}{#1}{#2},
  cancel/.code=\pktxd@addcancel{1},
  cancel2/.code=\pktxd@addcancel{2},
  cancel3/.code=\pktxd@addcancel{3},
  cancel4/.code=\pktxd@addcancel{4},
  delayed/.value required,
  delayed/.code 2 args={\pktxd@delayedtrue\edef\pktxd@delayedid{1}\edef\pktxd@delayedlen{#1}\edef\pktxd@delayedlabel{#2}},
  delayed2/.value required,
  delayed2/.code 2 args={\pktxd@delayedtrue\edef\pktxd@delayedid{2}\edef\pktxd@delayedlen{#1}\edef\pktxd@delayedlabel{#2}},
  delayed3/.value required,
  delayed3/.code 2 args={\pktxd@delayedtrue\edef\pktxd@delayedid{3}\edef\pktxd@delayedlen{#1}\edef\pktxd@delayedlabel{#2}},
  delayed4/.value required,
  delayed4/.code 2 args={\pktxd@delayedtrue\edef\pktxd@delayedid{4}\edef\pktxd@delayedlen{#1}\edef\pktxd@delayedlabel{#2}},
  stop/.value required,
  stop/.code n args={3}{\pktxd@stoptrue\edef\pktxd@stopid{1}
    \edef\pktxd@stoplen{#1}\edef\pktxd@stoplabel{#2}\edef\pktxd@stopdelay{#3}},
  stop2/.value required,
  stop2/.code n args={3}{\pktxd@stoptrue\edef\pktxd@stopid{2}\edef\pktxd@stoplen{#1}\edef\pktxd@stoplabel{#2}\edef\pktxd@stopdelay{#3}},
  stop3/.value required,
  stop3/.code n args={3}{\pktxd@stoptrue\edef\pktxd@stopid{3}\edef\pktxd@stoplen{#1}\edef\pktxd@stoplabel{#2}\edef\pktxd@stopdelay{#3}},
  stop4/.value required,
  stop4/.code n args={3}{\pktxd@stoptrue\edef\pktxd@stopid{4}\edef\pktxd@stoplen{#1}\edef\pktxd@stoplabel{#2}\edef\pktxd@stopdelay{#3}},
  %
  rnote/.code={\def\pktxd@rnote{#1}\pktxd@rnotetrue},
  snote/.code={\def\pktxd@snote{#1}\pktxd@snotetrue},
  %
  % TODO label2?
  %
  % collect unknown keys in style 'remainingkeys':
  % these may be tikz keys for the frame
  % from tex.stackexchange.com 22952
  .unknown/.code={%
    \let\currname\pgfkeyscurrentname%
    \let\currval\pgfkeyscurrentvalue%
    \ifx#1\pgfkeysnovalue%
    \pgfqkeys{/pktxd/frame}{remainingkeys/.append style/.expand once={\currname}}%
    \else%
    \pgfqkeys{/pktxd/frame}{remainingkeys/.append style/.expand twice={\expandafter\currname\expandafter=\currval}}%
    \fi}
}

\newif\ifpktxd@bad
\newif\ifpktxd@lost
\newif\ifpktxd@plop
\newif\ifpktxd@gone
\newif\ifpktxd@late
\newif\ifpktxd@delayed
\newif\ifpktxd@stop

\newif\ifpktxd@nocross
\newif\ifpktxd@snote
\newif\ifpktxd@rnote
\def\pktxd@snoteoffset{3mm}
\def\pktxd@rnoteoffset{3mm}

\newlength{\pktxd@prop}\setlength{\pktxd@prop}{0.5cm}
\newlength{\pktxd@latev}       %% amount of lateness if pktxd@latetrue

\def\pktxd@latename{$$lateframe}

\newif\ifpktxd@showlabelii
\newif\ifpktxd@hidelabel
\pgfkeyssetvalue{/pktxd/frame/label2}{}

%% internal styles

% .style since we fail to define several keys in a \if

\pgfkeys{
  % used internally for left timers when pktxd@bottomuptrue
  /pktxd/x/reverse/.style={/tikz/rotate=180,/tikz/above},
  % used for timer on arrow
  /pktxd/fill/.style={fill=\pktxd@bgcolor},
  % used for notes
  /pktxd/left note/.style={align=right,left},
  /pktxd/right note/.style={align=left,right},
  /pktxd/entities/style/.style={/tikz/.cd,thin},
  /pktxd/entities/label style/.style={/tikz/.cd,above,align=center}
}

%% flows

% env keys hide, ignore, and fade affect flows
\pgfkeys{/pktxd/.cd,
  %
  hide/.code=\pktxd@sethide{#1},
  ignore/.code=\pktxd@setignore{#1},
  fade/.code=\pktxd@setfade{#1},
}

\newcommand{\pktxd@sethide}[1]{
  \pgfkeyssetvalue{/pktxd/flows/#1/opacity}{0}}

\newcommand{\pktxd@setignore}[1]{\pgfkeyssetvalue{/pktxd/flows/#1/ignore}{1}}
\newif\ifpktxd@ignore

\newcommand{\pktxd@setfade}[1]{
  \pgfkeyssetvalue{/pktxd/flows/#1/opacity}{\pgfkeysvalueof{/pktxd/fade value}}}
\pgfkeyssetvalue{/pktxd/fade value}{0.25}


% the 'main' flow
\def\pktxd@fid{main}
\pgfkeyssetvalue{/pktxd/flows/main}{}

% default parameters for flows
\pgfkeyssetvalue{/pktxd/default}{}
\pgfkeyssetvalue{/pktxd/default/opacity}{1}


% get specific parameter #2 for flow #1, or default value
% this is currently only used for opacity
\newcommand{\pktxd@getflowconf}[2]{
  \pgfkeysifdefined{/pktxd/flows/#1/#2}
  {\pgfkeysvalueof{/pktxd/flows/#1/#2}}
  {\pgfkeysvalueof{/pktxd/default/#2}}}

%% styles
%%% commands

% define a style: name for a set of options
\newcommand{\definestyle}[2]{\pgfkeys{/pktxd/styles/#1/.style={#2}}}

% make #1 (dynamically) inherit #2, adding #3 options
\newcommand{\derivestyle}[3]{\definestyle{#1}{/pktxd/styles/#2,#3}}

%\definestyle{default}{}
%\definestyle{labeldefault}{}

% give a style to a flow or its labels
\newcommand{\setflowstyle}[2]{\pgfkeys{/pktxd/flows/#1/style/.initial=#2}}
\newcommand{\setflowlabelstyle}[2]{\pgfkeys{/pktxd/flows/#1/labelstyle/.initial=#2}}

%%% user keys

\pgfkeys{
  % env keys
  /pktxd/frame style/.code=\pgfkeys{/pktxd/styles/global/.style={#1}},
  /pktxd/frame style+/.code=\pgfkeys{/pktxd/styles/global/.style={very thick,-Latex,#1}},
  /pktxd/label style/.code=\pgfkeys{/pktxd/styles/label global/.style={#1}},
  /pktxd/label style+/.code=\pgfkeys{/pktxd/styles/label global/.style={above,sloped,#1}},
  % frame keys
  /pktxd/frame/style/.code=\pgfkeys{/pktxd/styles/this frame/.style={#1}},
  /pktxd/frame/label style/.code=\pgfkeys{/pktxd/styles/label this frame/.style={#1}}}

%%% hierarchy of styles

% the frame|label style of the current frame is styles/current frame|label style.
% This includes (in order):
% 1. the frame|label "global" style, that can be:
%   - augmented by the 'frame|label style+' key, or
%   - reset by the 'frame|label style' key,
% 2. the [label] style from the frame flow if any, else the empty style,
% 3. the local frame style set by the '[label] style' frame key.
%
% 1 and 3 are set by pgfkeys, 2 by pktxd@frame

\pgfkeys{
  /pktxd/styles/.cd,
  % styles for frames
  global/.style={very thick,-Latex},
  this frame/.style={},
  this flow/.style={},
  current frame style/.style={
    /pktxd/styles/global,
    /pktxd/styles/this flow,
    /pktxd/styles/this frame},
  % styles for frame labels
  label global/.style={above,sloped},
  label this frame/.style={},
  label this flow/.style={},
  current label style/.style={
    /pktxd/styles/label global,
    /pktxd/styles/label this flow,
    /pktxd/styles/label this frame},
  %
  .search also=/tikz
}

%% various definitions

% The state of the diagram (current send and receive times of each
% entity, running timers...) is changed when processing a frame but
% must persist accross the whole env.  We thus have to make it global.
% Hence we'll use \pgfglobalkeys, \pgfkeysgsetvalue (g for global) and
% \global\pgfkeyslet for the elements of the state.

\def\pgfglobalkeys#1{
  \begingroup
  \ifnum\the\globaldefs>0\relax
  \else \globaldefs=1\fi
  \pgfkeys{#1}\endgroup}

\def\pgfkeysgsetvalue#1#2{
  \begingroup
  \ifnum\the\globaldefs>0\relax
  \else \globaldefs=1\fi
  \pgfkeyssetvalue{#1}{#2}\endgroup}

% loop on entities: arg is code using \e
\newcommand{\pktxd@forallentities}[1]{
  \@for\e:=\pktxd@entities\do{
    \if\e\relax\else #1\fi
  }
}

\newcommand{\pktxd@createentity}[1]{
  \xdef\pktxd@entities{#1,\pktxd@entities}
  \pgfglobalkeys{/pktxd/entities/#1/ist/next-send/.initial=0cm} % next send time
  \pgfglobalkeys{/pktxd/entities/#1/ist/last-send/.initial=0cm} % last send time
  \pgfglobalkeys{/pktxd/entities/#1/ist/last-recv/.initial=0cm} % last recv time
  \pgfglobalkeys{/pktxd/entities/#1/ist/max/.initial=0cm}  % max time
  \pgfglobalkeys{/pktxd/entities/#1/style/.style={/pktxd/entities/style}}
  \pgfglobalkeys{/pktxd/entities/#1/label style/.style={/pktxd/entities/label style}}
  \pktxd@createtimer{#1}{l}{1}
  \pktxd@createtimer{#1}{l}{2}
  \pktxd@createtimer{#1}{l}{3}
  \pktxd@createtimer{#1}{l}{4}
  \pktxd@createtimer{#1}{r}{1}
  \pktxd@createtimer{#1}{r}{2}
  \pktxd@createtimer{#1}{r}{3}
  \pktxd@createtimer{#1}{r}{4}
}

%% getting/setting state

% where is the entity drawn
\newcommand{\pktxd@pos}[1]{\pgfkeysvalueof{/pktxd/entities/#1/pos}}

% instants are names for time value, stored in an entity
\newcommand{\pktxd@ist}[2]{\pgfkeysvalueof{/pktxd/entities/#1/ist/#2}}
\newcommand{\pktxd@sist}[3]{\global\pgfkeyslet{/pktxd/entities/#1/ist/#2}{#3}}

% these defined instants have set/get macros
\newcommand{\pktxd@Tsend}[1]{\pktxd@ist{#1}{next-send}}
\newcommand{\pktxd@Trecv}[1]{\pktxd@ist{#1}{last-recv}}
\newcommand{\pktxd@Tmax} [1]{\pktxd@ist{#1}{max}}

\newcommand{\pktxd@setTsend}[2]{\pktxd@sist{#1}{next-send}{#2}}
\newcommand{\pktxd@setTrecv}[2]{\pktxd@sist{#1}{last-recv}{#2}}
\newcommand{\pktxd@setTmax} [2]{\pktxd@sist{#1}{max}{#2}}

\newcommand{\pktxd@addtosend}[2]{
  \pgfmathsetlengthmacro\temp{\pktxd@Tsend{#1}+#2}
  \pktxd@setTsend{#1}{\temp}
  \ifdim\temp>\pktxd@Tmax{#1}
  \pktxd@setTmax{#1}{\temp}
  \fi
}

\newcommand{\pktxd@addtorecv}[2]{
  \pgfmathsetlengthmacro\temp{\pktxd@Trecv{#1}+#2}
  \pktxd@setTrecv{#1}{\temp}}

% if the pgfkey is defined in entity dir, use it
% otherwise use value in default dir
% TODO: currently only default entries are used (no key to set timer
% offsets on specific entities)
\newcommand{\pktxd@getconftimer}[4]{ % entity lr id name
  \pgfkeysifdefined{/pktxd/entities/#1/timers/#2/#3/#4}
  {\pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/#4}}
  {\pgfkeysvalueof{/pktxd/default/timers/#2/#3/#4}}}

\newcommand{\pktxd@gettimerstart}[3]{
  \pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/start}}

\newcommand{\pktxd@gettimerend}[3]{
  \pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/end}}

%% drawing a frame
%
% main macros are:
% - @nodelabel: draw a frame label
% - @arrowv: draw arrow for vertical diagram
% - @arrowh: draw arrow for horizontal diagram
% - @frame: main macro

%%% Draw a frame label: it can be made of:
%  - l1 label (passed as arg 2)
%  - the l2 label (passed as label2 option key)
%  - both

\newcommand{\pktxd@nodelabel}[2][1]{ % 1/-1, l1 label
  \ifpktxd@showlabelii\ifpktxd@hidelabel\itshape \pgfkeysvalueof{/pktxd/frame/label2}\else
  \ifnum #1=1
  \begin{tabular}{c}
    \itshape \pgfkeysvalueof{/pktxd/frame/label2}\\%[-3pt]
    #2
%    #2 \\[-3pt]
%    \if#2\empty\else#2 \\[-3pt]\fi
  \end{tabular}\else
  \begin{tabular}{c} % for A in hpktxd@, we want label2 to be below
    #2 \\
    \itshape \pgfkeysvalueof{/pktxd/frame/label2}
  \end{tabular}\fi
  \fi\else\ifpktxd@hidelabel{}\else#2\fi\fi}

\newlength{\pktxd@len}

%%% the draw arrow macro for vertical packet exchange diagram

% #1 are remaining keys (not handled by @frame) plus opacity,
% #2 is sender pos, #3 is receiver pos
% #4 is send time, #5 is label

% other inputs are:
% - kind of frame: pktxd@lost, pktxd@bad, pktxd@late, pktxd@plop
% - parameters:    pktxd@prop, pktxd@nocross, pktxd@latev
%    plus /pktxd/styles/current label style
%    and  /pktxd/styles/current frame style

% TODO: could error on plop and (late or lost or bad)
% TODO: should \newdimen's be global?
\newdimen\pktxd@len
\newif\ifpktxd@centerlabel

\newcommand{\pktxd@arrowv}[5][]{
  \def\lstyle{/pktxd/styles/current label style}

  \pktxd@debug{arrowv ##1=#1}
  
  % tex does not honor arithmetic priorities... pgfmath does.
  % \pgfmathsetlength{\pktxd@len}{#3-#2}
  \pktxd@len=#3
  \advance \pktxd@len by -#2
  
  \pgfmathsetmacro{\sign}{#2<#3?1:-1}

  % we put label at center of arrow if not in full duplex or lost frame
  \pktxd@centerlabelfalse
  \ifpktxd@sync\pktxd@centerlabeltrue\else
  \ifpktxd@lost\pktxd@centerlabeltrue\fi\fi

  \begin{scope}[/pktxd/styles/.cd,current frame style,#1]
    % iflost, draw only half way
    \ifpktxd@lost\def\lost{2}\else\def\lost{1}\fi

    % ifbad, draw a zigzag
    \ifpktxd@bad
       % can't be both bad and late
       \ifpktxd@late \pktxd@error{Frame both bad and late}
                                 {Sorry, a frame currently can't be both bad and late.}
       \else % @late

       % first segment, straight
       \draw (#2,-#4) --++(\pktxd@len/\lost/3,-\pktxd@prop/\lost/3)
       \ifpktxd@centerlabel\else
       node[align=center,near end,/pktxd/styles/.cd,\lstyle]{\pktxd@nodelabel{#5}}\fi
       % second segment, zigzag
       decorate[decoration=zigzag,segment length=2mm]
       {--++(\pktxd@len/\lost/3,-\pktxd@prop/\lost/3)
         \ifpktxd@centerlabel
         node[align=center,midway,/pktxd/styles/.cd,\lstyle]{\pktxd@nodelabel{#5}}\fi}
       % third segment, straight
       --++(\pktxd@len/\lost/3,-\pktxd@prop/\lost/3);
       \ifpktxd@lost\ifpktxd@nocross\else \draw[-]
       (\sign*2mm,-#4-\pktxd@prop/\lost)node{\Large $\times$}\fi\fi;
       \fi % @late

    \else % @bad

    % iflate, use control points (lost not accepted)
    \ifpktxd@late
       \ifpktxd@lost \pktxd@error{Frame both late and lost}
                                 {A frame can't be both late and lost.}
       \else
       \draw (#2,-#4) 
       .. controls (#2/2+#3/2,-#4-\pktxd@prop/2) and (#2/2+#3/2,-#4-\pktxd@latev)
       .. (#3, -#4-\pktxd@latev-\pktxd@prop)
                   node[align=center,/pktxd/styles/.cd,pos=0.1,\lstyle]{\pktxd@nodelabel{#5}};

       \fi % @lost

    \else % @late

    % plop frame, appearing at receiver
    \ifpktxd@plop
       \draw (#2+\pktxd@len/2,-#4-\pktxd@prop/2) -- ++(\pktxd@len/2,-\pktxd@prop/2)
                   node[align=center,midway,/pktxd/styles/.cd,\lstyle]{\pktxd@nodelabel{#5}};
       \newdimen\pktxd@ploplen
       \pgfmathsetlength{\pktxd@ploplen}{\pktxd@prop/\pktxd@len*3mm*\sign}
       \draw [dotted,-](#2+\pktxd@len/2,-#4-\pktxd@prop/2) -- ++(-3mm*\sign,\pktxd@ploplen);

    \else % @plop
    \ifpktxd@gone
      \draw[-] (#2,-#4) -- ++(\pktxd@len/2,-\pktxd@prop/2)
      node[align=center,midway,/pktxd/styles/.cd,\lstyle]{\pktxd@nodelabel{#5}};

      \newdimen\pktxd@ploplen
      \pgfmathsetlength{\pktxd@ploplen}{\pktxd@prop/\pktxd@len*3mm*\sign}
      \draw [dotted,-](#2+\pktxd@len/2,-#4-\pktxd@prop/2) -- ++(3mm*\sign,-\pktxd@ploplen);
    \else % @gone

    % not bad, late, gone, plop
    \def\pktxd@align{\ifpktxd@centerlabel midway\else near start\fi}
    \draw (#2,-#4) -- ++(\pktxd@len/\lost,-\pktxd@prop/\lost)
               node[align=center,\pktxd@align,
               /pktxd/styles/.cd,\lstyle]{\pktxd@nodelabel{#5}};
       \ifpktxd@lost\ifpktxd@nocross\else \draw[-]
                   (\sign*2mm,-#4-\pktxd@prop/\lost)node{\Large $\times$}\fi\fi;

    \fi % @gone
    \fi % @plop
    \fi % @late
    \fi % @bad
  \end{scope}
}

%%% the draw arrow macro for horizontal packet exchange diagram
%   TODO: doesn't need the /pktxd/styles/.cd?

\newcommand{\pktxd@arrowh}[5][]{
  \def\lstyle{/pktxd/styles/current label style}
  
  \pgfmathsetlength{\pktxd@len}{#2-#3}
  \pgfmathtruncatemacro{\sign}{#2<#3?1:-1}

  \begin{scope}[/pktxd/styles/current frame style,#1,|-|]
  \ifnum \sign>0\def\toto{above}\else\def\toto{below}\fi
  \ifpktxd@lost\def\lost{2}\else\def\lost{1}\fi
  % first draw 'transmission time' line
  \ifpktxd@bad

       \draw (#4,-#2) --++(\pktxd@trans/3,0)
                 decorate[decoration=zigzag,segment length=2mm]
                 {--++(\pktxd@trans/3,0) node[align=center,\lstyle,\toto=1mm,midway]{\pktxd@nodelabel[\sign]{#5}}}
                 --++(\pktxd@trans/3,0);
  \else
       \draw (#4,-#2) -- ++(\pktxd@trans,0)
           node[align=center,\lstyle,\toto=1mm,midway]{\pktxd@nodelabel[\sign]{#5}};
  \fi
  % then draw 'propagation time' arrow
  \draw[thin,->] (#4+\pktxd@trans,#3) -- ++ (\pktxd@prop/\lost,\pktxd@len/\lost);
  \ifpktxd@lost\ifpktxd@nocross\else \draw[-]
        (#4+\pktxd@trans+\pktxd@prop/2,\sign*-2mm) node{\Large $\times$}\fi\fi;
  \end{scope}
}


%%% the main macro for processing a frame command:
% - handle all frame keys (prop, trans, delayed, late...)
% - draw frame by calling @arrow, passing it style and remaining tikz keys
% - setup timers
% - draw notes
% - udpate time positions

\newcommand{\pktxd@frame}[4][]{ % [#1 keys], #2 sender, #3 receiver #4 label
  \edef\sendpos{\pktxd@pos{#2}}
  \edef\recvpos{\pktxd@pos{#3}}
  \edef\Tsend{\pktxd@Tsend{#2}}

  % update Tmax at sender
  \ifdim\Tsend>\pktxd@Tmax{#2}
  \pktxd@setTmax{#2}{\Tsend}
  \fi

  % which side are timers and send notes on?
  \edef\align{\ifdim\sendpos<\recvpos l\else r\fi}
  
  % process keys: apply settings in local scope
  \begin{scope}[/pktxd/frame/.cd, remainingkeys/.style={}, #1]

  % if flow has 'ignore' set, we're (almost) done
  \pgfkeysifdefined{/pktxd/flows/\pktxd@fid/ignore}{\pktxd@ignoretrue}{\pktxd@ignorefalse}
  \ifpktxd@ignore\else

  % update '/pktxd/styles/[label ]this flow' according to current flow
  \pgfkeysifdefined{/pktxd/flows/\pktxd@fid/style}
    {\pgfkeys{/pktxd/styles/this flow/.style=
      {/pktxd/styles/\pgfkeysvalueof{/pktxd/flows/\pktxd@fid/style}}}}{}
  \pgfkeysifdefined{/pktxd/flows/\pktxd@fid/labelstyle}
    {\pgfkeys{/pktxd/styles/label this flow/.style=
      {/pktxd/styles/\pgfkeysvalueof{/pktxd/flows/\pktxd@fid/labelstyle}}}}{}
  
  \pktxd@settrans{#4}

  % delayed(i) key: fully process the timer
  \ifpktxd@delayed
    \pktxd@debug{delayed: len \pktxd@delayedlen ~ label \pktxd@delayedlabel ~ id \pktxd@delayedid}
    \edef\sTrecv{\pktxd@Trecv{#2}} % sender Trecv
    \pktxd@starttimer{#2}{\align}{\pktxd@delayedid}{\sTrecv}{\pktxd@delayedlen}{\pktxd@delayedlabel}
    \pktxd@setTsend{#2}{\sTrecv}%%%
    \pktxd@addtosend{#2}{\pktxd@delayedlen}
    \edef\Tsend{\pktxd@Tsend{#2}}
    \pktxd@endtimer{#2}{\align}{\pktxd@delayedid}
  \fi

  % stop(i) key: fully process the timer
  \ifpktxd@stop
    \pktxd@debug{stop: len \pktxd@stoplen ~ label \pktxd@stoplabel ~delay \pktxd@stopdelay ~ id \pktxd@stopid}
    \edef\sTrecv{\pktxd@Trecv{#2}} % sender Trecv
    \pktxd@starttimer{#2}{\align}{\pktxd@stopid}{\sTrecv}{\pktxd@stoplen}{\pktxd@stoplabel}
    \pktxd@setTsend{#2}{\sTrecv}
    \pktxd@addtosend{#2}{\pktxd@stopdelay}
    \edef\Tsend{\pktxd@Tsend{#2}}
    \pktxd@canceltimer{#2}{\align}{\pktxd@stopid}{\Tsend}
  \fi

  % timed[i] keys have populated @timeds
  \@for\timed:=\pktxd@timeds\do{\expandafter\pktxd@processtimed\timed:#2}

  % set opacity based on fid key
  \def\opa{\pktxd@getflowconf{\pktxd@fid}{opacity}}
  
  % draw send note
  \ifpktxd@snote
  \ifpktxd@h
    \pktxd@drawnote{\Tsend}{#2}{s}{\pktxd@snote}
    {\if\align l-\fi\pktxd@snoteoffset}{/pktxd/styles/current frame style,
      /pktxd/left note,opacity=\opa}
  \else
    \pktxd@drawnote{\Tsend}{#2}{s}{\pktxd@snote}
    {\if\align l-\fi\pktxd@snoteoffset}{/pktxd/styles/current frame style,
      \if\align l/pktxd/left note\else/pktxd/right note\fi,opacity=\opa}
  \fi
  \fi
  % draw frame
  % explicit tikz keys are in /pktxd/frame/remainingkeys and may
  % override \thestyle
  \pktxd@arrow[/tikz/opacity=\opa,/pktxd/frame/remainingkeys]
      {\sendpos}{\recvpos}{\Tsend}{#4}

  % Trecv is frame reception time at receiver
  \pgfmathsetlengthmacro\Trecv{\Tsend+\pktxd@prop+\pktxd@trans}

  % draw receive note
  \ifpktxd@rnote
  \ifpktxd@h
    \pktxd@drawnote{\Trecv-\pktxd@latev}{#3}{r}{\pktxd@rnote}
    {\if\align r-\fi\pktxd@rnoteoffset}{/pktxd/styles/current frame style,
      /pktxd/right note,opacity=\opa}
  \else
    \pktxd@drawnote{\Trecv-\pktxd@latev}{#3}{r}{\pktxd@rnote}
    {\if\align r-\fi\pktxd@rnoteoffset}{/pktxd/styles/current frame style,
      \if\align l/pktxd/right note\else/pktxd/left note\fi,opacity=\opa}
  \fi
  \fi

  % late key
  \edef\Tcancel{\Trecv}
  \ifpktxd@late
    % no simpler way to do that?
    \pgfmathsetlengthmacro\Tcancel{\Trecv+\pktxd@latev}
    \global\pgfkeyslet{/pktxd/values/#3/\pktxd@latename}{\Tcancel}
    \setlength\pktxd@latev{0mm}
  \fi

  % commit time updates
  \pktxd@sist{#2}{last-send}{\Tsend}
  \pgfmathsetlengthmacro\Tsend{\Tsend+\pktxd@trans+\pktxd@senddelay}
  \pktxd@setTsend{#2}{\Tsend}
  \pktxd@setTrecv{#3}{\Trecv}
  
  % update Tmax at receiver
  % (Tcancel set above to Trecv + pktxd@latev if late)
  \ifdim\Tcancel>\pktxd@Tmax{#3}
  \pktxd@setTmax{#3}{\Tcancel}
  \fi

  % if not full duplex, update Tsend at receiver
  \ifpktxd@sync
    \pgfmathsetlengthmacro\Tsndr{\Trecv+\pktxd@replydelay}
    \pktxd@setTsend{#3}{\Tsndr}
  \fi

  % cancel[i] keys have populated @cancels
  \@for\id:=\pktxd@cancels\do{
    \if 0\id\else
    \pktxd@debug{cancel \id}
    \pktxd@canceltimer{#3}{\if l\align r\else l\fi}{\id}{\Tcancel}
    \fi}

  \fi %pktxd@ignore
  \end{scope}
}


%% handling of timers
%%% visual settings

% env keys and corresponding state
\pgfkeys{/pktxd/.cd,
  % TODO: merge in one key?
  timers/.is choice,
  timers/left bottom up/.is if=pktxd@timerleftbottomup,
  timers/left below/.is if=pktxd@timerleftbelow,
  timers/on arrow/.code={\pktxd@timeronarrowtrue\def\pktxd@timerlabeladd{#1}},
  timers/on arrow/.default=5mm
}
\newif\ifpktxd@timerleftbottomup
\newif\ifpktxd@timerleftbelow
\newif\ifpktxd@timeronarrow
% timer label on arrow effective only if label width+this value is
% less than the timer width
\def\pktxd@timerlabeladd{}

% so that arrows of consecutive timers are spaced a very little bit
\pgfkeys{/pktxd/timer time offset/.code=
               \setlength{\pktxd@timertoffset}{#1}}
\newlength{\pktxd@timertoffset}\setlength{\pktxd@timertoffset}{0.2mm}

%%% timer state

% a timer belongs to an entity, is leftist or rightist and is timer n
% on its side (n=1..4)

% active: 0 or t if the timer is currently running
% cancel: 0 or t if the timer has just been cancelled
% label : timer label
% start time
% end time

\newcommand{\pktxd@createtimer}[3]{ % entity l/r id
  \pgfkeysgsetvalue{/pktxd/entities/#1/timer/#2/#3/active}{0}
  \pgfkeysgsetvalue{/pktxd/entities/#1/timer/#2/#3/cancel}{0}
  \pgfkeysgsetvalue{/pktxd/entities/#1/timer/#2/#3/label}{0}
  \pgfkeysgsetvalue{/pktxd/entities/#1/timer/#2/#3/start}{0}
  \pgfkeysgsetvalue{/pktxd/entities/#1/timer/#2/#3/end}{0}}

%%% current frame timers

% @timeds is the list of timers started by current frame
% it has a dumb last element to avoid the loop break on a final comma
% - initialized here (global scope)
% - elements are added by timed[i] key frames, calling @addtimed
%   (in @frame scope, no need to reset)
% - @processtimed is called in @frame

\def\pktxd@timeds{0/0/0}

\newcommand{\pktxd@addtimed}[3]{
  \pktxd@debug{addtimed #1,#2,#3}
  \edef\pktxd@timeds{#1/#2/{#3},\pktxd@timeds}}

\def\pktxd@processtimed #1/#2/#3:#4{ % id/len/label:entity
  \if 0#1\else
  \pktxd@debug{timed: id #1 ~ len #2 ~ label #3}
  \pgfmathsetlengthmacro\temp{\Tsend+\pktxd@trans}
  \pktxd@starttimer{#4}{\align}{#1}{\temp}{#2}{#3}\fi}

% @cancels is the list of timers cancelled by current frame
% similar to @timeds

\def\pktxd@cancels{0}

\newcommand{\pktxd@addcancel}[1]{
  \edef\pktxd@cancels{#1,\pktxd@cancels}}

%%% timer offsets

% The (horizontal) offset of the four timers is set to a default
% that is sensible if using timer labels.

\pgfkeys{/pktxd/default/timers/.cd,
    l/1/offset/.initial=4mm,
    l/2/offset/.initial=9mm,
    l/3/offset/.initial=14mm,
    l/4/offset/.initial=19mm,
    r/1/offset/.initial=4mm,
    r/2/offset/.initial=9mm,
    r/3/offset/.initial=14mm,
    r/4/offset/.initial=19mm
  }

% keys to adjust offsets for timer 1/2/3/4

\pgfkeys{/pktxd/.cd,
  %
  % set offset for pairs of 1/2/3/4 timers
  timer offset/.style={/pktxd/A timer offset=#1,/pktxd/B timer offset=#1},
  timer2 offset/.style={/pktxd/A timer2 offset=#1,/pktxd/B timer2 offset=#1},
  timer3 offset/.style={/pktxd/A timer3 offset=#1,/pktxd/B timer3 offset=#1},
  timer4 offset/.style={/pktxd/A timer4 offset=#1,/pktxd/B timer4 offset=#1},
  %
  % set offset for a single timer
  % A and B names make sense only for AB diagrams, this is actually l/r timer
  A timer offset/.style={/pktxd/default/timers/l/1/offset=#1},
  A timer2 offset/.style={/pktxd/default/timers/l/2/offset=#1},
  A timer3 offset/.style={/pktxd/default/timers/l/3/offset=#1},
  A timer4 offset/.style={/pktxd/default/timers/l/4/offset=#1},
  B timer offset/.style={/pktxd/default/timers/r/1/offset=#1},
  B timer2 offset/.style={/pktxd/default/timers/r/2/offset=#1},
  B timer3 offset/.style={/pktxd/default/timers/r/3/offset=#1},
  B timer4 offset/.style={/pktxd/default/timers/r/4/offset=#1},
  %
  % set offsets of 2/3/4 as increment of #1 on timer 1 offset
  /pktxd/timers/+offset/.code=\pktxd@settimeroffsets{#1},
  /pktxd/timers/+offset/.value required,
  %
  % set them all to a tight value (suitable w/o labels)
  /pktxd/timers/tight/.code=
     \pgfkeys{/pktxd/timer offset=2mm,
              /pktxd/timers/on arrow}  % ensures @lefttimeraddoffset not used
     \pktxd@settimeroffsets{2mm}
}

% only used by keys above
% set all timer offsets: timer_i set to timer_1 offset + (i-1) * #1
\def\pktxd@settimeroffsets#1{
  \@for\s:=l,r\do{
    \def\basicoffset{\pgfkeysvalueof{/pktxd/default/timers/\s/1/offset}}
    \@for\i:=1,2,3,4\do{
      \pgfmathsetlengthmacro{\offset}{\basicoffset+(\i-1)*#1}
      \pgfkeyslet{/pktxd/default/timers/\s/\i/offset}{\offset}
    }
  }
}

% more offset is added to left timers if "normal" left timer labels are used
% (see @drawtimer)
\def\pktxd@lefttimeraddoffset{3mm}

%%% timer processing and drawing

\newif\ifpktxd@putlabelonarrow
\newlength{\pktxd@labellength}
\newlength{\pktxd@temp}

% entity, start time, end time, cancel time (or x), label, pos offset,
% arrow style, label style
% label not drawn if \relax!
% TODO include cancel arrow style?

\newcommand{\pktxd@drawtimer}[8]{
  \pktxd@debug{drawtimer #1, #2/#3/#4 .#5. #6}

  \newif\iflabel % should draw label?
  \if#5\relax\labelfalse\else\labeltrue\fi

  % @putlabelonarrow will be set if 'timer label on arrow' is set
  % and label is not too wide
  \pktxd@putlabelonarrowfalse
  \ifpktxd@timeronarrow
    \settowidth{\pktxd@labellength}
      %% need this to use settowidth in tikzpicture
      {\pgfinterruptpicture#5\endpgfinterruptpicture}  %% should use #8?
    \addtolength{\pktxd@labellength}{\pktxd@timerlabeladd}
    \pgfmathsetlength\pktxd@temp{#3-#2}
    \ifdim\pktxd@labellength<\pktxd@temp
      \pktxd@putlabelonarrowtrue
    \fi
  \fi

  % pos is entity pos + offset
  % get side from offset sign
  \def\entitypos{\pktxd@pos{#1}}
  \def\offset{#6}
  \def\side{\ifdim#6<0cm l\else r\fi}
  \def\pos{
    \ifpktxd@h
       -\entitypos-\offset
    \else
       \entitypos+\if\side r                \offset\else
                  \ifpktxd@timerleftbelow   \offset\else
                  \ifpktxd@timerleftbottomup\offset\else
                  \ifpktxd@putlabelonarrow  \offset\else
                                            \offset-\pktxd@lefttimeraddoffset
                  \fi\fi\fi\fi
    \fi}

  \ifpktxd@putlabelonarrow
     \def\above{/pktxd/fill}
  \else
  \ifpktxd@h\def\above{above}\else
    %% get label orientation for v diagrams
    %% the timer label is placed above except if:
    %% - it's a left timer and @timerleftbelow is set (placed below)
    %% - it's a left timer and @timerleftbottomup is set (placed above +
    %% rotate).  We use /pktxd/x/reverse in this case cause we don't know
    %% how to pass two keys in a single macro... -> expandafter?
    \if\side r\def\above{above}\else
    \ifpktxd@timerleftbelow\def\above{below}\else
    \ifpktxd@timerleftbottomup\def\above{/pktxd/x/reverse}\else
    \def\above{above}\fi
    \fi\fi
  \fi\fi

  % for h diagrams, need an additionnal offset
  % TODO: should be configurable (haddoffset)

  \edef\timerhoffset{\if\side r
    % side r
    \if#1\ifpktxd@reversed A\else B\fi
    \ifpktxd@putlabelonarrow 4mm\else 7mm\fi\else 3mm\fi\else
    % side l
    \if#1\ifpktxd@reversed B\else A\fi-3mm\else 0mm\fi\fi}

  \if x#4 % no cancel
    \ifpktxd@h
      \draw[thin,<->,#7] (#2,\pos-\timerhoffset)
           -- (#3,\pos-\timerhoffset) \iflabel node[midway,sloped,\above,#8]{#5}\fi;
    \else
      \draw[thin,<->,#7] (\pos,-#2-\pktxd@timertoffset)
           -- (\pos,-#3+\pktxd@timertoffset) \iflabel node[midway,sloped,\above,#8]{#5}\fi;
    \fi
  \else % including a cancel
    \ifpktxd@h
      \draw[thin,#7](#2,\pos-\timerhoffset) -- (#4,\pos-\timerhoffset);
      \draw[thin,dotted,<->,#7](#2,\pos-\timerhoffset)
           -- (#3,\pos-\timerhoffset) \iflabel node[midway,sloped,\above,#8]{#5}\fi;
    \else
      \draw[thin,#7](\pos,-#2-\pktxd@timertoffset) -- (\pos,-#4);
      \draw[thin,dotted,<->,#7](\pos,-#2-\pktxd@timertoffset)
           -- (\pos,-#3+\pktxd@timertoffset) \iflabel node[midway,sloped,\above,#8]{#5}\fi;
    \fi
  \fi
}

\newcommand{\pktxd@endtimerifactive}[3]{
  \if\pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/active}t
  \pktxd@endtimer{#1}{#2}{#3}\fi}

% timer h position: based on hpos, l/r alignment and offset
% in horizontal, hpos is negated (left/- is up/+)
% in vertical, remove 3mm to l timers if neither @timerleftbelow nor
% @timerleftbottomup is set

\newcommand{\pktxd@settimerhpos}[4]{ % entity/lr/id macro
  \pktxd@debug{timerhpos #1/#2/#3}
  \def\pos{\pktxd@pos{#1}}
  \def\offset{\pktxd@getconftimer{#1}{#2}{#3}{offset}}
  \edef#4{%
  \ifpktxd@h-\pos+\if #2r-\offset\else\offset\fi
  \else
  \pos+\if #2r\offset\else\ifpktxd@timerleftbelow-\offset\else\ifpktxd@timerleftbottomup-\offset
  \else-\offset-3mm\fi\fi\fi\fi}}

\newcommand{\pktxd@starttimer}[6]{ % entity, l/r, id, starttime, len, label
  \pktxd@endtimerifactive{#1}{#2}{#3}
  \pgfkeysgsetvalue{/pktxd/entities/#1/timers/#2/#3/active}{t}
  \pgfkeysgsetvalue{/pktxd/entities/#1/timers/#2/#3/cancel}{0}
  \global\pgfkeyslet{/pktxd/entities/#1/timers/#2/#3/start}{#4}
  \pgfmathsetlengthmacro\temp{#4+#5}
  \global\pgfkeyslet{/pktxd/entities/#1/timers/#2/#3/end}{\temp}
  % we store the label as \relax if empty
  \def\empty{}\edef\arg{#6}\ifx\arg\empty\edef\arg{\relax}\fi
  \global\pgfkeyslet{/pktxd/entities/#1/timers/#2/#3/label}{\arg}

  \pktxd@debugtimer{starttimer}{#1}{#2}{#3}
}

\newcommand{\pktxd@debugtimer}[4]{
  \pktxd@debug{#1 timer #2/#3/#4}
  \pktxd@debug{start \pktxd@gettimerstart{#2}{#3}{#4}}
  \pktxd@debug{end   \pktxd@gettimerend{#2}{#3}{#4}}
}

% macro for showing an incorrect timer cancelling
\def\pktxd@errorcanceltimer#1#2#3{% text time hpos
  \pktxd@error{You're trying to cancel an #1 timer}
    {A prominent yellow box has been drawn to show where the cancel
     was requested.}
  \ifpktxd@h
    \node at (#2,#3)[draw,red,fill=yellow]{Cancel #1 timer!};
  \else
    \node at (#3,-#2)[draw,red,fill=yellow]{Cancel #1 timer!};
  \fi
}

\newcommand{\pktxd@canceltimer}[4]{ % entity, l/r, id, time
  \pktxd@debugtimer{canceltimer #4}{#1}{#2}{#3}
  \newif\iferror
  % check timer is indeed active...
  \if\pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/active}t\errorfalse\else\errortrue\fi
  \iferror\pktxd@errorcanceltimer{non running}{#4}{\pktxd@pos{#1}}
  \else
  % good, it is!
  \pgfkeysgsetvalue{/pktxd/entities/#1/timers/#2/#3/active}{0}
  \pgfkeysgsetvalue{/pktxd/entities/#1/timers/#2/#3/cancel}{t}
  \def\timerstart{\pktxd@gettimerstart{#1}{#2}{#3}}
  \def\timerend{\pktxd@gettimerend{#1}{#2}{#3}}
  \def\timeroffset{\if#2l-\fi\pktxd@getconftimer{#1}{#2}{#3}{offset}}

  \pktxd@settimerhpos{#1}{#2}{#3}{\hpos}

  \ifdim#4>\timerend % now check it's not too late to cancel
     \pktxd@errorcanceltimer{expired}{#4}{\hpos}
     % we draw it anyway
     \pktxd@drawtimer{#1}{\timerstart}{\timerend}{x}
        {\pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/label}}
        {\timeroffset}{}{}
     \pktxd@drawtimer{#1}{\timerend}{#4}{x}{\relax}{\timeroffset}{dotted,red,->}{}
  \else
     % everything is ok!
    \pktxd@drawtimer{#1}{\timerstart}{\timerend}{#4}
        {\pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/label}}{\timeroffset}{}{}
  \fi
  \fi
}

% finish drawing a timer
\newcommand{\pktxd@endtimer}[3]{
  \pgfkeysgsetvalue{/pktxd/entities/#1/timers/#2/#3/active}{0}
  \pgfkeysgsetvalue{/pktxd/entities/#1/timers/#2/#3/cancel}{0}
  \def\timerstart{\pktxd@gettimerstart{#1}{#2}{#3}}
  \def\timerend{\pktxd@gettimerend{#1}{#2}{#3}}
  \def\timeroffset{\if#2l-\fi\pktxd@getconftimer{#1}{#2}{#3}{offset}}
  
  \pktxd@drawtimer{#1}{\timerstart}{\timerend}{x}
    {\pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/label}}{\timeroffset}{}{}
}

%% notes

\newcommand{\pktxd@drawnote}[6]{ % timepos, entity, s/r, note, offset, style
  \pktxd@debug{note: #1 #2 #3 [note text] #5 #6 } % #4 fails if multi-line
  \edef\pos{\pgfkeysvalueof{/pktxd/entities/#2/pos}}

  % horizontal diagram
  \ifpktxd@h
  % is the note going up or down?
  % here we decide that notes sent by A/received by B go down, and others up
  % we could also make all notes go down (but need to be consistent
  % with style set by @frame)
  \edef\orient{\if#3s\ifdim\pos<0pt d\else u\fi\else\ifdim\pos>0pt d\else u\fi\fi}
  % to account for trans time,
  % a sent if offset to the right, a recv to the left
  \edef\dpos{\if#3s 4mm\else-4mm\fi}
  \if\orient d   % down
    \node[rotate=-90,#6] at (#1+\dpos, -\pos\if#3r-\else+\fi 10mm) { #4 };
  \else          % up
    \node[rotate=90,#6] at (#1+\dpos, -\pos\if#3r+\else-\fi 10mm) { #4 };
  \fi
  \else

  % vertical diagram
  \node[#6] at (\pos+#5, -#1) { #4 };
  \fi}

%% side decorations (eg for TCP)

\pgfkeys{/pktxd/.cd,
  %
  action time offset/.code=\setlength{\pktxd@actiontimeoffset}{#1},
  action offset/.code=\setlength{\pktxd@actionoffset}{#1},
  action length/.code=\setlength{\pktxd@actionlength}{#1},
  state offset/.code=\setlength{\pktxd@stateoffset}{#1}
}

\newlength{\pktxd@actiontimeoffset}\setlength{\pktxd@actiontimeoffset}{1mm}
\newlength{\pktxd@actionoffset}\setlength{\pktxd@actionoffset}{1mm}
\newlength{\pktxd@actionlength}\setlength{\pktxd@actionlength}{5mm}
\newlength{\pktxd@stateoffset}\setlength{\pktxd@stateoffset}{12mm}

\newcommand{\pktxd@action}[4]{ % timepos, hpos, l/r, text
  \ifpktxd@h\else
  \if#3l\def\align{left}\else\def\align{right}\fi
  \draw[<-](#2+\if#3l-\pktxd@actionoffset\else\pktxd@actionoffset\fi,-#1+\pktxd@actiontimeoffset)
           -- ++(\if#3l180\else0\fi:\pktxd@actionlength) node[\align]{#4};
  \fi}

\newcommand{\pktxd@state}[4]{ % timepos, hpos, l/r, text
  \ifpktxd@h\else
  \if#3l\def\align{left}\else\def\align{right}\fi
  \draw(#2+\if#3l-\pktxd@stateoffset\else\pktxd@stateoffset\fi,-#1)
       node[draw,\align]{\textsc{#4}};
  \fi}

\newcommand{\Astate}[1]{\pktxd@state{\pAs}{\pktxd@pos{A}}{l}{#1}}
\newcommand{\Bstate}[1]{\pktxd@state{\pBs}{\pktxd@pos{B}}{r}{#1}}

\newcommand{\Aactionstate}[2]{
  \pktxd@action{\pAs}{\pktxd@pos{A}}{l}{#1}
  \pktxd@state{\pAs-5mm}{\pktxd@pos{A}}{l}{#2}}

\newcommand{\Bactionstate}[2]{
  \pktxd@action{\pBs}{\pktxd@pos{B}}{r}{#1}
  \pktxd@state{\pBs-5mm}{\pktxd@pos{B}}{r}{#2}}


%% laters
%
% A later has two effects:
% 1. it advances time: this is done immediately
% 2. it is drawn (erasing entity lines and possibly timers): this will
%    be done when env is closed.  It is thus stored in /pktxd/laters.

\newlength{\pktxd@laterdashedlen}
\setlength{\pktxd@laterdashedlen}{1cm}
\pgfkeys{/pktxd/laters/.initial={0cm/0cm}}

\newcommand{\later}[1]{
  % store for drawing at close of env
  \pgfkeys{/pktxd/laters/.append/.expanded={,\pAs/#1}}
  % advance time
  \pktxd@addtosend{A}{#1}
  \pktxd@addtorecv{A}{#1}
  \pktxd@addtosend{B}{#1}
  \pktxd@addtorecv{B}{#1}
}

% iterator on timers: used by @drawlater
\newcommand{\pktxd@alltimers}[1]{
  \foreach \e/\o in {A/l,B/r} {
    \foreach \n in {1,2,3,4} {
      #1{\e}{\o}{\n}
      }
    }
  }

% warning: uses \tpos (dynamic scope?)
\newcommand{\pktxd@drawlateronetimer}[3]{
  \pktxd@settimerhpos{#1}{#2}{#3}{\hpos}
  \draw[\pktxd@bgcolor,dashed] (\hpos,\tpos) -- ++(0,\pktxd@laterdashedlen);}

% draw one later: erase part of the vertical lines
% starttime len
\newcommand{\pktxd@drawlater}[2]{
  \def\tpos{-#1-#2/2-\pktxd@laterdashedlen/2}

  % entity lines
  \ifpktxd@h\else
  \draw[\pktxd@bgcolor,dashed](\pktxd@pos{A},\tpos) -- ++(0,\pktxd@laterdashedlen);
  \draw[\pktxd@bgcolor,dashed](\pktxd@pos{B},\tpos) -- ++(0,\pktxd@laterdashedlen);
  \fi

  % timer lines
  \ifpktxd@h\else
  \pktxd@alltimers{\pktxd@drawlateronetimer}
  \fi
}

%% TODO - not about laters

\newcommand{\pktxd@setpos}[2]{
  \pgfmathsetlengthmacro{\toto}{#2}
  \pgfkeyslet{/pktxd/entities/#1/pos}{\toto}}


\newcommand{\Xpause}[2][\pktxd@pausedefault]{\pktxd@addtosend{#2}{#1}}

% X waits for Y, Y waits for X (usefull only in fullduplex mode)

\newcommand{\XwaitY}[2]{
  \edef\temp{\pktxd@Trecv{#1}}
  \pktxd@setTsend{#1}{\temp}
  \pktxd@debug{Xwait temp=\temp Tsend=\pktxd@Tsend{#1}}
  \pktxd@addtosend{#1}{\pktxd@replydelay}}

% set Tsend to end of the timer if it's later
% also set Tmax to endtimer - finaldelay
% (to not extend Tmax below a last timer)
\newcommand{\pktxd@waittimer}[3]{
  \edef\timerend{\pktxd@gettimerend{#1}{#2}{#3}}
  \edef\Tsend{\pktxd@Tsend{#1}}
  \edef\Tmax{\pktxd@Tmax{#1}}
  \ifdim \Tsend<\timerend\pktxd@setTsend{#1}{\timerend}\fi
  \pgfmathsetlengthmacro\timerbis{\timerend-\pktxd@finaldelay}
  \ifdim \Tmax<\timerbis\pktxd@setTmax{#1}{\timerbis}\fi
}


%% shortcut macros for two entities diagrams

\newcommand{\AB}[2][]{\pktxd@frame[#1]{A}{B}{#2}}
\newcommand{\BA}[2][]{\pktxd@frame[#1]{B}{A}{#2}}

\newcommand{\Apause}[1][\pktxd@pausedefault]{\Xpause[#1]{A}}
\newcommand{\Bpause}[1][\pktxd@pausedefault]{\Xpause[#1]{B}}

\newcommand{\AwaitB}{\XwaitY{A}{B}}
\newcommand{\BwaitA}{\XwaitY{B}{A}}

% arg is name set in the late frame ('name' key, defaults to $$lateframe)
\newcommand{\Awaitlate}[1][$$lateframe]{
  \edef\pktxd@trecv{\pgfkeysvalueof{/pktxd/values/A/#1}}
  \pktxd@setTrecv{A}{\pktxd@trecv}
  \AwaitB}

\newcommand{\Bwaitlate}[1][$$lateframe]{
  \edef\pktxd@trecv{\pgfkeysvalueof{/pktxd/values/B/#1}}
  \pktxd@setTrecv{B}{\pktxd@trecv}
  \BwaitA}
  
% A,B waits for its current timer to expire
\newcommand{\Awaittimer}[1][1]{\pktxd@waittimer{A}{l}{#1}}
\newcommand{\Bwaittimer}[1][1]{\pktxd@waittimer{B}{r}{#1}}

% A sends a timed frame to B
% [keys], flabel, len, tlabel

\newcommand{\ABtimed} [4][]{\AB[#1,timed={#3}{#4}]{#2}}
\newcommand{\ABtimedi}[4][]{\AB[#1,timed2={#3}{#4}]{#2}}
\newcommand{\BAtimed} [4][]{\BA[#1,timed={#3}{#4}]{#2}}
\newcommand{\BAtimedi}[4][]{\BA[#1,timed2={#3}{#4}]{#2}}

% A sends a frame that cancels B's timer

\newcommand{\ABcancel} [2][]{\AB[cancel,#1]{#2}}
\newcommand{\ABcanceli}[2][]{\AB[cancel2,#1]{#2}}
\newcommand{\BAcancel} [2][]{\BA[cancel,#1]{#2}}
\newcommand{\BAcanceli}[2][]{\BA[cancel2,#1]{#2}}

% A sets a timer and sends a frame when it expires
% [keys], len, tlabel, flabel
\newcommand{\ABdelayed}[4][]{\AB[#1,delayed={#2}{#3}]{#4}}
\newcommand{\BAdelayed}[4][]{\BA[#1,delayed={#2}{#3}]{#4}}

% A sets a timer and after a delay sends a frame that cancels it
% typical use: ACK timer cancelled by sending of DATA
% [keys], len, tlabel, delay, flabel
\newcommand{\ABstop}[5][]{\AB[#1,stop={#2}{#3}{#4}]{#5}}
\newcommand{\BAstop}[5][]{\BA[#1,stop={#2}{#3}{#4}]{#5}}

% TODO - it this useful?
% shortcuts
\def\pAs{\pktxd@Tsend{A}}
\def\pBs{\pktxd@Tsend{B}}
\def\pAr{\pktxd@Trecv{A}}
\def\pBr{\pktxd@Trecv{B}}


%% intialize entities

\newcommand{\pktxd@entityname}[2]{\pgfkeyssetvalue{/pktxd/entities/#1}{#2}}
\newcommand{\pktxd@entitysetpic}[3]{\pgfkeyssetvalue{/pktxd/entities/#1/pic}{\includegraphics[#3]{#2}}}

% in two entities mode
\def\pktxd@initentities{
  \def\pktxd@entities{\relax}
  \pktxd@createentity{A}
  \pktxd@createentity{B}
  \def\pktxd@A{\ifpktxd@reversed B\else A\fi}
  \def\pktxd@B{\ifpktxd@reversed A\else B\fi}
  \pktxd@setpos{\pktxd@A}{-\pktxd@width/2}
  \pktxd@setpos{\pktxd@B}{\pktxd@width/2}
  \pktxd@debugentities{two mode}
}

% in multiple entities mode
\newlength{\currentpos}

\def\pktxd@initmentities#1{
  \gdef\pktxd@entities{\relax}
  \setlength{\currentpos}{0cm}
  \foreach \e/\n/\w in {#1} {
    \ifx\n\w\def\w{\pktxd@width}\fi
    \addtolength{\currentpos}{\w}
    \pktxd@debug{entity \e ~ name \n ~ width \w ~ position \the\currentpos}
    \pktxd@createentity{\e}
    \pgfglobalkeys{/pktxd/entities/\e/.initial/.expanded=\n}
    \pgfglobalkeys{/pktxd/entities/\e/pos/.initial/.expanded=\the\currentpos} 
    % see http://tex.stackexchange.com/questions/33125/tikz-foreach-and-sum
    % for some reason, we can't \global the \addtolength above
    \global\currentpos=\currentpos
  }
  \pktxd@debugentities{multiple mode}
  \pktxd@mmodetrue
}
    
\def\pktxd@debugentities#1{
  \ifpktxd@debug
    \typeout{entities: #1}
    \pktxd@forallentities {
      \edef\name{\pgfkeysvalueof{/pktxd/entities/\e}}
      \edef\pos{\pgfkeysvalueof{/pktxd/entities/\e/pos}}
      \typeout{entity: \e/\name/\pos}
    }
  \fi
}


% compute the maximum time of all entities, in \maxtime
% arg is added offset to Trecv

\newcommand{\pktxd@computemaxtime}[1]{
  \def\maxtime{0pt}
  \pktxd@forallentities{
    \edef\tmax{\pktxd@Tmax{\e}}
    \ifdim \maxtime<\tmax \edef\maxtime{\tmax}\fi
  }
  \pktxd@debug{final maxtime=\maxtime}
}

\newcommand{\pktxd@flushtimer}[3]{
  \if\pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/active}t
    \pktxd@endtimer{#1}{#2}{#3}
    \pktxd@waittimer{#1}{#2}{#3}
  \else
    \if\pgfkeysvalueof{/pktxd/entities/#1/timers/#2/#3/cancel}t
      \pgfkeysgsetvalue{/pktxd/entities/#1/timers/#2/#3/cancel}{0}
      \pktxd@debugtimer{flush/cancel}{#1}{#2}{#3}
      \pktxd@debug{pos#1 = \pktxd@Tsend{#1}}
      \pktxd@waittimer{#1}{#2}{#3}
      \pktxd@debug{updated pos#1 = \pktxd@Tsend{#1}}
  \fi\fi}

\newcommand{\pktxd@finishtimers}{
  \pktxd@forallentities{
    \pktxd@flushtimer{\e}{l}{1}
    \pktxd@flushtimer{\e}{l}{2}
    \pktxd@flushtimer{\e}{l}{3}
    \pktxd@flushtimer{\e}{l}{4}
    \pktxd@flushtimer{\e}{r}{1}
    \pktxd@flushtimer{\e}{r}{2}
    \pktxd@flushtimer{\e}{r}{3}
    \pktxd@flushtimer{\e}{r}{4}
  }
}


%% user environments

\newenvironment{pktxdiag}[1][]{
  \pktxd@debug{entering pktxdiag env}
  \newcommand{\fullduplex}{\pktxd@syncfalse}%
  \newcommand{\halfduplex}{\pktxd@synctrue}%
  \def\frame{\pktxd@frame}%
  \def\pktxd@arrow{\pktxd@arrowv}%
  \def\entityname{\pktxd@entityname}%
  \def\entitypic{\pktxd@entitysetpic}%
  %
  \pktxd@hfalse%
  \setlength{\pktxd@trans}{0cm}%
  \begin{tikzpicture}[tight background,
    background rectangle/.style={fill=\pktxd@bgcolor},
    show background rectangle,
    /pktxd/.cd,#1]\sffamily
    \ifpktxd@mmode\else\pktxd@initentities\fi
  }
  { % closing pktxdiag env
    % 1. finish drawing all timers
    %    this also moves Tsend to end of timer if needed
    \pktxd@finishtimers

    % 2. draw entity lines, pictures, and labels
    %    this in done on layer 'entities' to stay behind other drawings
    \pktxd@computemaxtime{\pktxd@replydelay}
    \pktxd@len=\maxtime
    \advance \pktxd@len by \pktxd@finaldelay

    \newif\ifpktxd@picdefined
    
    \begin{pgfonlayer}{entities}
      \pktxd@forallentities {
        % not reset to \relax accross envs?
        \def\myname{\pgfkeysvalueof{/pktxd/entities/\e}}
        \def\mypic{\pgfkeysvalueof{/pktxd/entities/\e/pic}}
        \pgfkeysifdefined{/pktxd/entities/\e/pic}
        {\pktxd@picdefinedtrue}{\pktxd@picdefinedfalse}
        \def\mylabel{
          \ifpktxd@picdefined
            \ifpktxd@picontop  % pic on top of label
              \mypic\\[\pktxd@picoffset]\myname
            \else              % label on top of pic
              \myname\\[\pktxd@picoffset]\mypic
            \fi
          \else              % just the label
            \myname
          \fi}
        \draw[/pktxd/entities/\e/style] (\pktxd@pos{\e},\pktxd@initialdelay)
        node[/pktxd/entities/\e/label style] {\mylabel}
        -- (\pktxd@pos{\e},-\pktxd@len);
      }
    \end{pgfonlayer}

    % 3. draw later(s)
    \pgfkeys{/pktxd/laters/.get=\laters}
    \foreach \t/\l in \laters {
      %\pktxd@debug{time \t~ len \l}
      \ifdim\t=0cm\else\pktxd@drawlater{\t}{\l}\fi
    }

    % 4. remove entities names
    %    they are set through pgfglobalkeys and would persist accross envs
    \pktxd@forallentities {
      \pgfglobalkeys{/pktxd/entities/\e/.initial=\relax}
    }
  \end{tikzpicture}
  \pktxd@debug{exiting pktxdiag env}
}

\newenvironment{hpktxdiag}[1][]{
  \newcommand{\fullduplex}{\pktxd@syncfalse}%
  \newcommand{\halfduplex}{\pktxd@synctrue}%
  \def\frame{\pktxd@frame}%
  \def\pktxd@arrow{\pktxd@arrowh}%
  \def\entityname{\pktxd@entityname}%
  %
  \pktxd@htrue%
  \setlength{\pktxd@senddelay}{0cm}%
  \setlength{\pktxd@replydelay}{0cm}%
  \def\pktxd@width{1cm}%
  \setlength{\pktxd@prop}{3mm}%
  \begin{tikzpicture}[tight background,
    background rectangle/.style={fill=\pktxd@bgcolor},
    show background rectangle,
    /pktxd/.cd,#1]\sffamily
  \ifpktxd@mmode
  \PackageError{pktxdiag}{Multi-entities mode not supported in h
    diagrams}{Multi-entities mode was triggered by use of 'entities'
    key.  This occured in a hpktxdiag environment, however horizontal
    diagrams do not support multi-entities mode.}
  \fi
  \pktxd@initentities
  }
  {
    % finish drawing all timers
    \pktxd@finishtimers

    % draw labels (we could do it at env opening)
    \pktxd@forallentities {
      \draw(-\pktxd@senddelay/2,-\pktxd@pos{\e}) node[align=center,left]{\pgfkeysvalueof{/pktxd/entities/\e}};
  }
  % add to the right margin to get centered picture
  \pktxd@computemaxtime{2mm}
  \draw(\maxtime,0) node {};

  % no need to remove names : /pktxd/A|B/.code sets them in env scope
  % (contrary to @initmentities)
\end{tikzpicture}}

% Local Variables:
% outline-regexp: "%%+"
% End:
